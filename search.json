[{"title":"JavaScript异步编程：从回调到Promise","url":"/2023/08/03/Promise/","content":"什么是异步先来看下面这样一个关于时间规划的小学数学题：\n\n题目：四年级小敏每天起床后要做的事情有：穿衣（3分钟），整理床铺（2分钟），洗脸梳头（8分钟），上厕所（5分钟），烧饭（20分钟），吃早饭（12分钟），完成这些工作要50分钟。你认为最合理的安排是多少分钟？\n答案：6:00 起床├─ 6:00-6:03 穿衣（3分钟）├─ 6:03-6:05 整理床铺（2分钟）├─ 6:05-6:25 烧饭（20分钟）│   ├─ 6:05-6:13 洗脸梳头（8分钟） ← 和烧饭完全重叠│   ╰─ 6:13-6:18 上厕所（5分钟）   ← 也在烧饭期间完成╰─ 6:25-6:30 吃早饭（5分钟）\n\n题目很简单，我们也能很快的想到答案，烧饭是一件很耗时且不需要太多人工参与的事情，我们就可以利用这段时间去处理其他事情。但这和异步有什么关系呢？\n可以简单的说，像题目中这样：在同一时间段内，可以同时处理多件事情，不需要等前一个事情处理完成，才能处理下一个的场景，就是异步。在同一时间段内，只能处理一件事情，需要等待前一个事情处理完成后，才能开始处理下一个事情的场景，就是同步。\n在程序的世界里，也存在许多类似于烧饭的处理，例如：文件的I&#x2F;O处理、数据库操作等。在同步代码中，当一个任务（如读取文件、数据库查询）执行时，整个线程会被阻塞，无法处理其他请求，导致CPU空闲等待。这不仅会影响到用户的体验，还造成资源的浪费。\n而JavaScript 是单线程语言，同一时间只能执行一个任务，那该如何解决这个问题呢？\n怎么实现异步回调函数有人可能会想到，我们可以使用回调函数来实现异步。例如：\n// 代码中用毫秒代替分钟setTimeout(() =&gt; &#123;    console.log(&quot;6:05-6:13 洗脸梳头（8分钟）&quot;);        setTimeout(() =&gt; &#123;        console.log(&quot;6:13-6:18 上厕所（5分钟）&quot;);        // 烧饭完成后        setTimeout(() =&gt; &#123;            console.log(&quot;6:25 饭烧好了&quot;);        &#125;, 20 - 5 - 8); // 烧饭时间减去已经过去的时间            &#125;, 8); // 洗脸梳头8分钟    &#125;, 5); // 穿衣+整理床铺共5分钟/*输出：    6:05-6:13 洗脸梳头（8分钟）    6:13-6:18 上厕所（5分钟）    6:25 饭烧好了*/\n\n但如果使用回调函数来描述整个场景呢？\nconsole.log(&quot;6:00 起床&quot;);setTimeout(() =&gt; &#123;    console.log(&quot;6:00-6:03 穿衣（3分钟）&quot;);    setTimeout(() =&gt; &#123;        console.log(&quot;6:03-6:05 整理床铺（2分钟）&quot;);        console.log(&quot;6:05-6:25 开始烧饭（20分钟）&quot;);        // 在烧饭期间并行执行其他任务        setTimeout(() =&gt; &#123;            console.log(&quot;6:05-6:13 洗脸梳头（8分钟）&quot;);                            setTimeout(() =&gt; &#123;                console.log(&quot;6:13-6:18 上厕所（5分钟）&quot;);                                // 烧饭完成后                setTimeout(() =&gt; &#123;                    console.log(&quot;6:25 饭烧好了&quot;);                                        setTimeout(() =&gt; &#123;                        console.log(&quot;6:25-6:30 吃早饭（5分钟）&quot;);                        console.log(&quot;6:30 所有任务完成&quot;);                    &#125;, 5); // 5分钟吃早饭                &#125;, 20 - 13); // 烧饭总时间减去已经过去的时间            &#125;, 8); // 穿衣+整理床铺+洗脸梳头共13分钟        &#125;, 5); // 穿衣+整理床铺共5分钟    &#125;, 2); // 整理床铺2分钟&#125;, 3); // 穿衣3分钟/*输出：\t6:00 起床    6:00-6:03 穿衣（3分钟）    6:03-6:05 整理床铺（2分钟）    6:05-6:25 开始烧饭（20分钟）    6:05-6:13 洗脸梳头（8分钟）    6:13-6:18 上厕所（5分钟）    6:25 饭烧好了    6:25-6:30 吃早饭（5分钟）    6:30 所有任务完成*/\n\n可以看到，函数嵌套的过深，不仅影响了代码的可读性，还会难以调试和维护。在JavaScript异步编程中，这种多层嵌套回调函数形成的复杂代码结构被称为回调地狱（Callback Hell）。\n\n回调地狱（Callback Hell），也称为金字塔厄运（Pyramid of Doom），是指 JavaScript 中由于多层嵌套回调函数导致的代码结构复杂、难以维护的现象。\n带来的问题：\n​\t① 代码可读性差\n​\t② 错误处理复杂\n​\t③ 调试困难\n​\t……\n\n但在实际的开发中，我们不可避免的会遇到这种复杂的业务场景，该怎么解决回调地狱的问题呢？\nPromiseJavaScript中的一种异步编程模式，解决了回调地狱的问题，帮助开发者更清晰地处理异步操作，使代码更易读、易维护。\n核心原理与工作机制Promise 本质上是一个内置构造函数，用于创建 Promise 对象实例。每个 Promise 实例内部维护着两个关键属性：\n\nPromiseState（状态机）：\n\npending：初始状态，表示异步操作正在进行中\nfulfilled：操作成功完成（通过 resolve() 触发）\nrejected：操作失败或被拒绝（通过 reject() 或抛出异常触发）\n\n\nPromiseResult（结果容器）：\n\n存储异步操作的返回值（resolve 传入的值）\n或存储错误信息（reject 传入的错误对象）\n\n\n\n状态转换规则：\n\n创建时自动初始化为 pending 状态\n通过 resolve(value) 转换为 fulfilled，并存储结果值\n通过 reject(reason) 或抛出异常转换为 rejected，并存储错误信息\n状态转换是单向且不可逆的，一旦确定就不可更改\n\n执行流程：\n\n实例化 Promise 时，执行器函数（executor）立即执行\n通过 then() 方法注册回调：\n当状态变为 fulfilled，触发第一个回调函数\n当状态变为 rejected，触发第二个回调函数（或 catch()）\n\n\n通过 finally() 注册最终回调（无论成功失败都会执行）\n\n优点\n避免回调地狱\n链式调用\n错误处理更简单\n…..\n\n基本用法/*\t1. 创建一个 Promise 对象\t创建Promise时，构造函数接收一个执行器函数，在函数里写具体的处理逻辑，\t函数中有两个参数resolve/reject，这两个参数也是方法，在操作完成时调用。\t· resolve(value)：当异步操作成功时调用，存储成功信息。\t· reject(reason)：当异步操作失败时调用，存储错误信息。*/const myPromise = new Promise((resolve, reject) =&gt; &#123;\t// 异步操作......    if(condition) &#123;\t// 处理成功        resolve(&quot;成功！&quot;);\t// 调用 resolve    &#125; else &#123;\t// 处理失败        reject(&quot;失败！&quot;); // 调用 reject    &#125;&#125;);/*\t2. 使用 then/catch/finally 处理执行结果        then(result): Promise成功时执行            - 接收成功结果            - 可返回新值（成为新Promise的resolve值）            - 可链式调用        catch(error): Promise失败时执行\t            - 专门处理错误            - 可捕获前面所有then中的错误            - 也能返回新值        finally(): 无论成功失败都执行\t            - 不接收参数            - 通常放在最后，用于清理操作            - 不影响Promise链的最终值*/myPromise  .then((result) =&gt; &#123;    console.log(&quot;成功结果:&quot;, result);    return &quot;新的值&quot;; // 可传递给下一个then  &#125;)  .catch((error) =&gt; &#123;    console.error(&quot;失败原因:&quot;, error);    throw new Error(&quot;处理错误&quot;); // 可继续抛出错误  &#125;)  .finally(() =&gt; &#123;    console.log(&quot;无论成功失败都会执行&quot;);  &#125;);\n\n核心特点\n\n\n特性\n说明\n\n\n\n状态不可逆\npending → fulfilled（成功）或 rejected（失败）\n\n\n链式调用\n.then() 返回新的 Promise，可继续 .then()\n\n\n错误冒泡\n错误会一直传递到最近的 .catch()\n\n\n微任务队列\nPromise 回调属于微任务（比 setTimeout 宏任务优先级高）\n\n\n常用方法以下是 Promise 静态方法的对比汇总表格：\n\n\n\n方法\n描述\n成功条件\n失败条件\n返回值\n特点\n\n\n\nPromise.resolve()\n创建立即完成的Promise\n总是成功\n无\n传入的值\n快速包装值为Promise\n\n\nPromise.reject()\n创建立即拒绝的Promise\n无\n总是失败\n传入的错误\n快速创建拒绝的Promise\n\n\nPromise.all()\n处理多个Promise\n所有Promise成功\n任意一个失败\n结果数组（按输入顺序）\n一个失败立即拒绝，不等待其他\n\n\nPromise.allSettled()\n处理多个Promise\n所有Promise完成（无论成功失败）\n不会失败\n状态对象数组：&#123;status: &#39;fulfilled&#39;, value&#125;&#123;status: &#39;rejected&#39;, reason&#125;\n等待所有Promise最终状态\n\n\nPromise.race()\n处理多个Promise\n第一个完成的Promise（成功&#x2F;失败）\n第一个失败的Promise\n第一个完成的结果\n只关心最先完成的结果\n\n\nPromise.any()\n处理多个Promise\n任意一个Promise成功\n全部Promise失败\n第一个成功的结果\n忽略拒绝，只取第一个成功值\n\n\n示例代码：\n// Promise.allPromise.all([p1, p2]).then(results =&gt; &#123;  console.log(&#x27;所有成功:&#x27;, results); // [v1, v2]&#125;).catch(err =&gt; &#123;  console.log(&#x27;首个失败:&#x27;, err);&#125;);// Promise.allSettledPromise.allSettled([p1, p2]).then(results =&gt; &#123;  results.forEach(result =&gt; &#123;    if (result.status === &#x27;fulfilled&#x27;) &#123;      console.log(&#x27;成功:&#x27;, result.value);    &#125; else &#123;      console.log(&#x27;失败:&#x27;, result.reason);    &#125;  &#125;);&#125;);// Promise.racePromise.race([p1, p2]).then(winner =&gt; &#123;  console.log(&#x27;首个完成:&#x27;, winner);&#125;);// Promise.anyPromise.any([p1, p2]).then(firstSuccess =&gt; &#123;  console.log(&#x27;首个成功:&#x27;, firstSuccess);&#125;).catch(err =&gt; &#123;  console.log(&#x27;全部失败:&#x27;, err.errors); // AggregateError&#125;);\n\n使用场景建议：\n\n全成功才继续：用 Promise.all\n收集所有结果：用 Promise.allSettled\n竞速响应：用 Promise.race\n任一成功即可：用 Promise.any\n\n重构时间规划问题// 创建一个延迟执行的 Promise 辅助函数function delay(taskName, minutes) &#123;  return new Promise(resolve =&gt; &#123;    setTimeout(() =&gt; &#123;      console.log(`$&#123;taskName&#125;（$&#123;minutes&#125;分钟）`);      resolve();    &#125;, minutes); // 用毫秒代替分钟，便于演示  &#125;);&#125;// 主流程开始console.log(&quot;6:00 起床&quot;);// 穿衣delay(&quot;6:00-6:03 穿衣&quot;, 3)  .then(() =&gt; &#123;    // 整理床铺    return delay(&quot;6:03-6:05 整理床铺&quot;, 2);  &#125;)  .then(() =&gt; &#123;    console.log(&quot;6:05-6:25 开始烧饭（20分钟）&quot;);        // 烧饭主任务    const cooking = delay(&quot;6:25 饭烧好了&quot;, 20);        // 并行任务1: 洗脸梳头    const faceWashing = delay(&quot;6:05-6:13 洗脸梳头&quot;, 8);        // 并行任务2: 上厕所（在洗脸梳头之后）    const toilet = faceWashing.then(() =&gt; delay(&quot;6:13-6:18 上厕所&quot;, 5));        // 等待所有并行任务完成    return Promise.all([cooking, toilet]);  &#125;)  .then(() =&gt; &#123;    // 吃早饭    return delay(&quot;6:25-6:30 吃早饭&quot;, 5);  &#125;)  .then(() =&gt; &#123;    console.log(&quot;6:30 所有任务完成&quot;);  &#125;)  .catch(error =&gt; &#123;    console.error(&quot;流程出错:&quot;, error);  &#125;);\n\n虽然通过链式调用可以解决回调地狱的问题，但是我们还是可以看到then()中嵌套then()的现象，代码的可读性还是不够好。\nasync&#x2F;await是什么？async&#x2F;await 是 ES2017 引入的语法糖，基于 Promise 的异步编程解决方案，让异步代码拥有同步代码的书写方式。\n核心本质：\n\nasync：将函数标记为异步，总是返回 Promise 对象\nawait：暂停异步函数执行，等待 Promise 解决\n\n用法通过async可以来创建一个异步函数，async函数会返回一个Promise对象。\n1. 声明异步函数async function fetchData() &#123;  return &#x27;data&#x27;; // 自动包装为 resolved Promise&#125;// 等价于function fetchData() &#123;  return Promise.resolve(&#x27;data&#x27;);&#125;\n\n2. 等待异步结果async function getUser() &#123;  const response = await fetch(&#x27;/api/user&#x27;); // 等待Promise解决  const data = await response.json(); // 再次等待  return data;&#125;\n\n注意事项1.使用范围await只能在async函数中使用，或ES模块的顶层作用域中使用。await阻塞的只是异步函数内部的代码，不会影响外部代码。\n\nES模块的顶层作用域是什么？\nES模块的顶层作用域指的是在模块的最外层，不在任何函数或类内部的代码块。这种情况下，顶层作用域的代码会在模块加载时立即执行。\n\nhtml中：\n\n&lt;script type=&quot;module&quot;&gt;    await Promise.resolve().then(() =&gt; console.log(&quot;Hello&quot;));&lt;/script&gt;\n2. 错误处理通过await调用异步代码时，需要通过try…catch来捕获异常\n// 方式1：try/catchasync function fetchWithTryCatch() &#123;  try &#123;    const data = await fetchData();  &#125; catch (err) &#123;    console.error(&#x27;捕获错误:&#x27;, err);  &#125;&#125;// 方式2：catch回调async function fetchWithCatch() &#123;  const data = await fetchData().catch(err =&gt; &#123;    console.error(&#x27;捕获错误:&#x27;, err);  &#125;);&#125;\n\n3. 并行优化// 错误：顺序执行（耗时较长）async function sequential() &#123;  const a = await fetchA(); // 等待完成  const b = await fetchB(); // 才开始&#125;// 正确：并行执行async function parallel() &#123;  const [a, b] = await Promise.all([fetchA(), fetchB()]);&#125;\n\n常见陷阱\n忘记await：导致后续代码使用未resolved的Promise\nasync function demo() &#123;  const data = fetchData(); // 缺少await！  console.log(data); // 输出: Promise &#123;&lt;pending&gt;&#125;&#125;\n\n不必要await：同步操作无需await\nasync function unnecessary() &#123;  await console.log(&#x27;这不需要await&#x27;); // 反模式&#125;\n\n循环中使用：可能需要重构为for…of顺序执行\nasync function processArray(array) &#123;  for (const item of array) &#123; // 替代forEach/map    await processItem(item);  &#125;&#125;\n\n重构时间规划问题// 辅助函数：模拟延迟执行并记录时间async function delay(taskName, minutes) &#123;    return new Promise(resolve =&gt; &#123;        setTimeout(() =&gt; &#123;            console.log(`$&#123;taskName&#125;（$&#123;minutes&#125;分钟）`);            resolve();        &#125;, minutes); // 用毫秒代替分钟，便于演示    &#125;);&#125;// 主流程async function morningRoutine() &#123;    console.log(`6:00 起床`);    // 顺序执行穿衣和整理床铺    await delay(&quot;6:00-6:03 穿衣&quot;, 3);    await delay(&quot;6:03-6:05 整理床铺&quot;, 2);    // 开始烧饭并并行执行其他任务    console.log(`6:05 开始烧饭（20分钟）`);    // 并行执行的任务    const tasks = [        // 洗脸梳头（8分钟）和上厕所（5分钟）的链式调用        (async () =&gt; &#123;            // 洗脸梳头（8分钟）            await delay(&quot;6:05-6:13 洗脸梳头&quot;, 8);// 上厕所（5分钟）            return await delay(&quot;6:13-6:18 上厕所&quot;, 5);        &#125;)(),        // 烧饭任务（20分钟）        delay(&quot;6:25 饭烧好了&quot;, 20)    ];    await Promise.all(tasks);    // 吃早饭    await delay(&quot;6:25-6:30 吃早饭&quot;, 5);    console.log(&quot;6:30 所有任务完成&quot;);&#125;// 执行流程morningRoutine().catch(err =&gt; console.error(&quot;流程出错:&quot;, err));\n\nJS是单线程的，那么它是如何实现异步处理的呢？\n在深入探讨解决方案之前，让我们先理解一个概念：事件循环（Event Loop）。JavaScript 通过事件循环（Event Loop）机制，在保持单线程执行模型的同时，实现了异步操作的高效处理。下面我们将详细解析这一重要机制。\n原理：事件循环（Event Loop）事件循环是JavaScript中的一个的运行时模型，负责程序执行期间的资源管理、任务处理和协调操作，它定义了代码如何被调度和执行的。\n关键组件\n\n\n组件\n说明\n常见例子\n\n\n\n调用栈（Call Stack）\n同步代码的执行栈，遵循后进先出（LIFO）。若栈溢出（如无限递归）会报错。\n同步代码（如 console.log）、函数调用\n\n\n任务队列（Task Queue）\n即宏任务队列，是事件循环中处理”常规”异步任务的队列。\nsetTimeout、setInterval、DOM事件、I&#x2F;O（如 fs.readFile）\n\n\n微任务队列（Microtask Queue）\n存放微任务，每轮事件循环结束后立即清空，优先级高于宏任务。\nPromise.then、MutationObserver、queueMicrotask、process.nextTick。\n\n\n事件循环(Event Loop)关键组件示意图\nflowchart TD\n    subgraph 队列\n        direction LR\n        subgraph 任务队列_宏任务队列[\"任务队列（宏任务队列）\"]\n            H[setTimeout]\n            I[setInterval]\n            J[DOM事件]\n            K[I/O回调]\n        end\n        \n        subgraph 微任务队列[\"微任务队列\"]\n            E[Promise.then]\n            F[queueMicrotask]\n            G[MutationObserver]\n        end\n    end\n    \n    subgraph 调用栈[\"调用栈\"]\n        A[全局执行上下文] --> B[函数1]\n        B --> C[函数2]\n        C --> D[console.log]\n    end\n执行流程简化的执行顺序：1. 同步代码 → 2. 微任务 → 3. 宏任务\n\n调用栈检查阶段\n事件循环首先检查调用栈(Call Stack)状态\n若调用栈不为空，则继续执行栈中的同步代码\n若调用栈为空，则进入任务队列处理阶段\n\n\n微任务处理阶段\n当调用栈清空后，事件循环会优先处理微任务队列(Microtask Queue)\n依次执行微任务队列中的所有任务，直到队列完全清空\n\n\n宏任务处理阶段\n在微任务队列清空后，从宏任务队列(Macrotask Queue)中取出一个任务执行\n执行完毕后立即返回微任务检查阶段\n\n\n\n上述过程形成持续的事件循环(Event Loop)，每次宏任务执行后都会重新检查微任务队列，这种机制保证了高优先级任务的及时处理。\nflowchart TD\n    Start([开始]) --> Sync[执行同步代码]\n    Sync --> Micro{微任务队列空?}\n    Micro -->|否| ExecuteMicro[执行微任务] --> Micro\n    Micro -->|是| Macro{宏任务队列空?}\n    Macro -->|否| ExecuteMacro[执行宏任务] --> Sync\n    Macro -->|是| End([结束])","categories":["JavaScript"],"tags":["异步编程","回调","Promise"]},{"title":"深入理解 Promise：从零实现一个符合规范的 Promise 类","url":"/2025/08/09/MyPromise/","content":"第1版：基础骨架核心功能\nPromise 对象有三种状态，它们之间的转换是不可逆的：\n\n\nPending（等待）：初始状态，既没有被兑现，也没有被拒绝\nFulfilled（已兑现）：意味着操作成功完成\nRejected（已拒绝）：意味着操作失败\n\n\n基本的resolve&#x2F;reject功能\n\nconst PROMISE_STATE = &#123;    PENDING: 0,    // 等待状态    FULFILLED: 1,  // 成功状态    REJECTED: 2    // 失败状态&#125;;class MyPromise &#123;    // 存储 Promise 的最终结果值（resolve 或 reject 传入的值）    #result;    // 跟踪 Promise 当前状态（PENDING/FULFILLED/REJECTED）    #state = PROMISE_STATE.PENDING;  // 初始状态    // 构造函数：接收一个“执行器”作为参数    constructor(executor) &#123;        // 调用回调函数        /*        \t注意，这里的写法一有问题，当使用方法一时，在#resolve和#reject中无法正确访问私有字段（如 #state、#result 等），            报错：Cannot read properties of undefined (reading &#x27;#state&#x27;)。原因如下：        \t1.this 指向丢失：当 #resolve 和 #reject 被直接作为参数传递时，它们会失去与当前Promise 实例的绑定            （this 会指向 undefined 或全局对象，严格模式下是 undefined）。            2.无法访问私有字段：由于 #resolve 和 #reject 是私有方法（以 # 开头），如果 this 指向不正确，            调用时会抛出错误，因为私有字段只能在类的内部访问。            写法二为什么正确？            bind(this) 确保 this 指向当前 Promise 实例，这样在 #resolve 和 #reject 内部可以正确访问            实例的私有字段（如 #state、#value 等）。        */        // 写法一：        // executor(this.#resolve, this.#resolve)        // 写法二：        executor(this.#resolve.bind(this), this.#reject.bind(this));        // 写法三（使用箭头函数）：        /*        \t在 JavaScript 中，箭头函数不会有自己的 this，它会捕获外部上下文中的 this。            因此，在这种写法中，箭头函数会使用当前上下文中的 this，也就是类的实例。            这确保了 this.#resolve 和 this.#reject 在执行时 this 始终指向正确的类实例。        */        // executor(value =&gt; this.#resolve(value), reason =&gt; this.#reject(reason));    &#125;\t// 用来存储成功的数据    #resolve(value) &#123;    \t// 保证状态只被设置一次，不可逆        if (this.#state !== PROMISE_STATE.PENDING) return;        this.#result = value;        this.#state = PROMISE_STATE.FULFILLED;    &#125;    // 用来存储错误的数据    #reject(reason) &#123;    \t// 保证状态只被设置一次，不可逆        if (this.#state !== PROMISE_STATE.PENDING) return;        this.#result = reason;        this.#state = PROMISE_STATE.REJECTED;    &#125;    // 添加一个用来读取数据的then方法    then(onFulfilled, onRejected) &#123;        if (this.#state === PROMISE_STATE.FULFILLED) &#123;            onFulfilled(this.#result);        &#125; else if (this.#state === PROMISE_STATE.REJECTED) &#123;            onRejected(this.#result);        &#125;    &#125;&#125;\n\n测试用例const mp = new MyPromise((resolve, reject) =&gt; &#123;    // resolve(1);\t// 正常输出    // reject(&#x27;error&#x27;); // 正常输出    setTimeout(() =&gt; &#123;resolve(&quot;111&quot;)&#125;, 1000); // 无输出&#125;);mp.then(    (result) =&gt; console.log(&quot;getResult: &quot;, result),\t(reason) =&gt; console.log(&quot;getReason: &quot;, reason));\n\n存在问题\n无法处理异步操作（setTimeout中的resolve）\nthen方法只能处理已确定的状态\n不支持链式调用\n\n第2版：支持异步回调问题分析1. 无法处理异步操作（如 setTimeout 中的 resolve）原因\nMyPromise 中的 then 方法只会在 Promise 的状态已经确定（即已经是 FULFILLED 或 REJECTED）时立即执行回调函数。但在 mp.then() 执行时，resolve(&quot;111&quot;) 还没有执行，state 还是 PROMISE_STATE.PENDING 状态，不满足if条件，所有没有任何输出。\n改进方案\n需要将 then 方法中的回调函数延迟执行，而不是在同步代码执行时立即执行。为此，使用一个队列来存储 then 的回调函数，当 Promise 状态变更时（即从 PENDING 变为 FULFILLED 或 REJECTED），依次调用这些回调函数。\n2. then 方法只能处理已确定的状态原因 在当前实现中，then 方法只处理 PENDING 状态之外的情况。对于 PENDING 状态，它没有做任何处理，这意味着 then 不能正确处理处于 PENDING 状态的 Promise。\n改进方案\n当 then 被调用时，如果 Promise 仍处于 PENDING 状态，应该将回调函数推入队列，等状态变为 FULFILLED 或 REJECTED 时再执行。\n改进版本const PROMISE_STATE = &#123;    PENDING: 0,    // 等待状态    FULFILLED: 1,  // 成功状态    REJECTED: 2    // 失败状态&#125;;class MyPromise &#123;    // 存储 Promise 的最终结果值（resolve 或 reject 传入的值）    #result;    // 跟踪 Promise 当前状态（PENDING/FULFILLED/REJECTED）    #state = PROMISE_STATE.PENDING;  // 初始状态    // 用于保存 then 的回调函数（支持链式调用）    #callbacks = [];    // 构造函数：接收一个“执行器”作为参数    constructor(executor) &#123;        // 调用回调函数        executor(this.#resolve.bind(this), this.#reject.bind(this));    &#125;    // 用来存储成功的数据    #resolve(value) &#123;        if (this.#state !== PROMISE_STATE.PENDING) return;        this.#result = value;        this.#state = PROMISE_STATE.FULFILLED;        // 异步执行回调        // 当 resolve 执行时，说明数据已经进来了，需要调用 then 中保存的回调函数        this.#executeCallbacks();    &#125;    // 用来存储错误的数据    #reject(reason) &#123;        // 保证状态只被设置一次，不可逆        if (this.#state !== PROMISE_STATE.PENDING) return;        this.#result = reason;        this.#state = PROMISE_STATE.REJECTED;        // 异步执行回调        // 当 resolve 执行时，说明数据已经进来了，需要调用 then 中保存的回调函数        this.#executeCallbacks();    &#125;    // 执行所有回调函数    #executeCallbacks() &#123;        for (const callback of this.#callbacks) &#123;            queueMicrotask(() =&gt; &#123;                callback(this.#result);            &#125;);        &#125;        this.#callbacks = [];  // 执行完清空回调队列    &#125;    then(onFulfilled, onRejected) &#123;        if (this.#state === PROMISE_STATE.FULFILLED) &#123;            // then 的回调函数，应该放入到微任务队列中执行，而不是直接调用            queueMicrotask(() =&gt; &#123;                onFulfilled(this.#result);            &#125;);        &#125; else if (this.#state === PROMISE_STATE.REJECTED) &#123;            // then 的回调函数，应该放入到微任务队列中执行，而不是直接调用            queueMicrotask(() =&gt; &#123;                onRejected(this.#result);            &#125;);        &#125; else &#123;            // 如果 Promise 处于 PENDING 状态，将回调放入队列            this.#callbacks.push(() =&gt; onFulfilled(this.#result));        &#125;    &#125;&#125;\n\n测试用例const p = new MyPromise((resolve, reject) =&gt; &#123;    setTimeout(() =&gt; resolve(&#x27;异步结果&#x27;), 1000 * 2);&#125;);// 2秒后输出两次&quot;异步结果&quot;p.then(res =&gt; &#123;    console.log(res);     return &quot;异步结果2&quot;;&#125;, error =&gt; &#123;    console.error(error)    return &quot;错误结果1&quot;&#125;);p.then(res =&gt; console.log(res), error =&gt; console.error(error));\n\n存在问题\n仍然不支持链式调用\n错误处理不完善\n没有处理then中回调函数的返回值\n\n第3版：完整链式调用问题分析1. 无法链式调用原因 目前的 then 方法没有返回新的 Promise 实例，这意味着每次调用 then 时都没有新的 Promise 返回，导致无法链式调用。链式调用需要 then 返回一个新的 Promise，这样下一个 then 就可以在之前的结果上继续执行。\n改进方案\n在 then 方法中返回一个新的 Promise，并且根据回调函数的执行结果来决定新 Promise 的状态。这确保了可以实现链式调用。\n2. 错误处理不完整原因\n当 onFulfilled 或 onRejected 回调抛出异常时，没有做任何处理。\n改进方案\n当 onFulfilled 或 onRejected 回调抛出异常时，应该返回一个新的 Promise，并使其变为 rejected 状态。\n3. 回调函数的正确传递原因\n回调函数被直接存储和执行，没有处理它们的返回值。\n改进方案\n在 then 的回调中返回一个新的 Promise，或者确保回调值正确传递给下一个 then。\n改进版本const PROMISE_STATE = &#123;    PENDING: 0,    FULFILLED: 1,    REJECTED: 2&#125;;class MyPromise &#123;    #result;    #state = PROMISE_STATE.PENDING;    #callbacks = [];    constructor(executor) &#123;        try &#123;            executor(this.#resolve.bind(this), this.#reject.bind(this));        &#125; catch (error) &#123;            this.#reject(error);        &#125;    &#125;    #resolve(value) &#123;        if (this.#state !== PROMISE_STATE.PENDING) return;        this.#result = value;        this.#state = PROMISE_STATE.FULFILLED;        this.#executeCallbacks();    &#125;    #reject(reason) &#123;        if (this.#state !== PROMISE_STATE.PENDING) return;        this.#result = reason;        this.#state = PROMISE_STATE.REJECTED;        this.#executeCallbacks();    &#125;    #executeCallbacks() &#123;        queueMicrotask(() =&gt; &#123;            for (const &#123; onFulfilled, onRejected, resolve, reject &#125; of this.#callbacks) &#123;                try &#123;                    if (this.#state === PROMISE_STATE.FULFILLED) &#123;                        const result = onFulfilled(this.#result);                        resolve(result);                    &#125; else if (this.#state === PROMISE_STATE.REJECTED) &#123;                        const result = onRejected(this.#result)                        reject(result);                    &#125;                &#125; catch (error) &#123;                    reject(error);                &#125;            &#125;            this.#callbacks = [];        &#125;);    &#125;    then(onFulfilled, onRejected) &#123;        return new MyPromise((resolve, reject) =&gt; &#123;            this.#callbacks.push(&#123;                onFulfilled,                onRejected,                resolve,                reject            &#125;);            // 如果状态已经确定，立即执行回调            if (this.#state !== PROMISE_STATE.PENDING) &#123;                this.#executeCallbacks();            &#125;        &#125;);    &#125;    catch(onRejected) &#123;        return this.then(null, onRejected);    &#125;&#125;\n\n测试用例const p = new MyPromise((resolve, reject) =&gt; &#123;    setTimeout(() =&gt; resolve(&#x27;异步结果&#x27;), 1000);&#125;);p.then(res =&gt; &#123;    console.log(res);  // 输出: 异步结果    return &#x27;新的结果&#x27;;&#125;).then(res =&gt; &#123;    console.log(res);  // 输出: 新的结果&#125;).catch(error =&gt; &#123;    console.error(error);&#125;);\n\n存在问题\n未处理 onFulfilled&#x2F;onRejected 不是函数的情况（值穿透）\n未实现静态方法（如 MyPromise.resolve&#x2F;MyPromise.reject）\n……\n\n关键点解析1. 为什么需要queueMicrotask？Promise的回调必须异步执行，且需要在当前脚本执行完成后立即执行。微任务队列正好满足：\n\n比setTimeout更快\n在浏览器渲染前执行\n确保执行顺序的可预测性\n\n2. 链式调用的核心then(onFulfilled) &#123;    return new Promise((resolve) =&gt; &#123;        // 将前一个Promise的结果处理后传递给下一个        this.#callbacks.push(() =&gt; &#123;            resolve(onFulfilled(this.#result));        &#125;);    &#125;);&#125;\n\n3. 错误处理机制try &#123;    const result = onFulfilled(this.#result);    resolve(result);&#125; catch (error) &#123;    // 捕获同步错误，传递给下一个reject    reject(error);&#125;\n\n总结本篇博客仅简单实现了一个 Promise，要完全符合 Promises&#x2F;A+ 规范还需要更多工作。这个过程极大地加深了我对 JavaScript 异步编程的理解，深入理解了以下的概念：\n\nPromise 的状态机制（pending&#x2F;fulfilled&#x2F;rejected）\n异步回调的处理（queueMicrotask 的使用）\n链式调用的实现原理\n\n参考\nPromises&#x2F;A+ 规范\nECMAScript Promise 标准\n\n","categories":["JavaScript"],"tags":["异步编程","回调","Promise"]},{"title":"Node.js 模块化详解：从 CommonJS 到 ES Modules","url":"/2022/10/12/nodejs-modules/","content":"1. 模块化概述1.1 什么是模块化模块化是将代码分割成独立的模块，每个模块负责特定的功能或逻辑。这种编程范式将大型程序分解为相互依赖的小文件，提高了代码的可维护性、可重用性和可测试性。\n模块化的核心优势：\n\n可维护性：每个模块独立存在，修改一个模块不会影响其他模块\n可重用性：模块可以在不同项目中复用，减少重复代码\n可测试性：模块可以单独测试，确保功能正确性\n命名空间管理：避免全局变量污染，减少命名冲突\n\n1.2 模块化的历史背景JavaScript 在浏览器端的模块化方式经历了从全局作用域到基于 script 标签的引用再到现代化的模块系统（如 ES6 模块）。然而，Node.js 的模块化是基于 CommonJS 规范开发的，这使得 Node.js 在服务器端也能够非常方便地实现模块化。\n1.3 模块化解决的问题\n命名冲突：传统JS开发中全局变量容易冲突，模块化提供了独立作用域\n文件依赖：明确模块间的依赖关系，避免手动管理script标签顺序\n代码组织：使项目结构更清晰，便于团队协作开发\n\n2. CommonJS 模块规范2.1 基本概念CommonJS是Node.js默认采用的模块化规范，主要特点包括：\n\n同步加载模块\n适用于服务端环境\n使用require()导入，module.exports或exports导出\n\n2.2 基本用法模块导入\n// 导入自定义模块（需以./或../开头）const m1 = require(&#x27;./m1&#x27;) // 扩展名可省略// 导入核心模块（直接写模块名）const path = require(&#x27;path&#x27;)const fs = require(&#x27;node:fs&#x27;) // node:前缀可提高查找效率\n\n文件查找规则：\n\n完整文件名：直接加载\n省略扩展名：按.js → .json → .node顺序尝试\n目录作为模块：查找目录下的index.js\n\n模块导出\nconst add = (a, b) =&gt; a + b;const multiply = (a, b) =&gt; a * b;// 方式1：逐个导出exports.number = 1exports.method = function() &#123;&#125;exports.add = add; exports.multiply = multiply;// 方式2：整体导出module.exports = &#123;  name: &#x27;zs&#x27;,  age: 25,  add,   multiply&#125;\n\n注意：exports只是module.exports的引用，不能直接赋值：\nexports = &#123;a: 1&#125; // 错误！不会生效\n\n\n\n2.3 模块加载原理Node.js 在加载一个 CommonJS 模块（如 require(‘.&#x2F;module.js’)）时，会将该模块的代码包裹在一个函数里，并传入 5 个关键参数：\n\nexports：用于导出模块内容（等同于 module.exports 的引用）。\nrequire：用于引入其他模块的函数。\nmodule：当前模块的元信息（如 module.exports）。\n__filename：当前模块文件的绝对路径。\n__dirname：当前模块所在目录的绝对路径。\n\n示例代码假设有一个模块文件 math.js：\n// math.jsconsole.log(arguments); // 查看包装函数的参数const add = (a, b) =&gt; a + b;module.exports = add; // 导出 add 函数\n当你在另一个文件 app.js 中引入它：\n// app.jsconst add = require(&#x27;./math.js&#x27;);console.log(add(2, 3)); // 输出 5\n运行 app.js 时，math.js 会被包装成：\n(function(exports, require, module, __filename, __dirname) &#123;  console.log(arguments); // 输出包装函数的参数  const add = (a, b) =&gt; a + b;  module.exports = add;&#125;)(...); // Node.js 会自动传入 5 个参数\n可以通过console.log(arguments)查看这些参数。输出示例：\n&#123;  &#x27;0&#x27;: &#123;&#125;,               // exports（初始为空对象）  &#x27;1&#x27;: [Function: require], // require 函数  &#x27;2&#x27;: Module &#123; ... &#125;,   // module 对象  &#x27;3&#x27;: &#x27;/path/to/math.js&#x27;, // __filename  &#x27;4&#x27;: &#x27;/path/to&#x27;         // __dirname&#125;\n\n\n\n2.4 文件夹作为模块当 require 的是一个目录时，Node.js 会按顺序查找：\n\npackage.json 的 main 字段：指定入口文件。\nindex.js：如果 package.json 不存在或未指定 main。\n\n示例 1：目录包含 package.json假设目录结构如下：\nhello/  ├── package.json  ├── a.js  └── b.js\npackage.json 内容：\n&#123;  &quot;main&quot;: &quot;a.js&quot;&#125;\n当你 require(‘.&#x2F;hello’) 时，实际加载的是 hello&#x2F;a.js。\n示例 2：目录不包含 package.json目录结构：\nhello/  ├── index.js  ├── a.js  └── b.js\n当你 require(‘.&#x2F;hello’) 时，默认加载 hello&#x2F;index.js。\n示例 3：既无 package.json 也无 index.js会报错：\nError: Cannot find module &#x27;./hello&#x27;\n\n\n\n3. ES Modules 简介3.1 基本概念ES Modules (ESM) 是 JavaScript 的官方模块标准（ECMAScript 2015 引入），用于替代传统的 CommonJS（Node.js 原生的 require 语法）。\n\n设计目标：实现静态化模块依赖，支持异步加载，适合浏览器和服务器端。\n核心优势：\n静态分析（编译时确定依赖关系，利于优化）。\n原生浏览器支持（无需打包工具即可直接使用）。\n异步加载（更适合现代应用）。\n\n\n\n3.2 基本用法使用ES 模块时，文件扩展名需要改为 .mjs；如想使用 .js 作为文件扩展名，需要在 package.json 中声明 &quot;type&quot;: &quot;module&quot;。\n模块导入\n\n导入命名导出：\nimport &#123; add, PI &#125; from &#x27;./math.js&#x27;;\n\n导入默认导出：\nimport log from &#x27;./utils.js&#x27;;\n\n混合导入：\nimport log, &#123; add &#125; from &#x27;./combined.js&#x27;;\n\n动态导入（返回 Promise）：\nconst module = await import(&#x27;./module.js&#x27;);\n\n模块导出\n\n命名导出：导出多个值。\n// math.jsexport const add = (a, b) =&gt; a + b;export const PI = 3.14;\n\n默认导出：导出一个主要值。\n\n每个文件只能有一个默认导出\n\n// utils.jsexport default function log(message) &#123;  console.log(message);&#125;\n\n3.3 注意事项(1) 文件扩展名和路径\n\n必须显式指定扩展名（如 &#39;./math.js&#39;，不能省略 .js）。\n目录索引文件需完整路径（如 &#39;./dir/index.js&#39;，不能简写为 &#39;./dir&#39;）。\n\n\n可以通过配置打包工具（如 Webpack&#x2F;Rollup&#x2F;Vite）的配置文件，配置扩展名和路径\n例如：通过配置 resolve.extensions 和 resolve.mainFiles 实现：\n// webpack.config.jsmodule.exports = &#123;  resolve: &#123;    extensions: [&#x27;.js&#x27;, &#x27;.mjs&#x27;], // 自动补全扩展名    mainFiles: [&#x27;index&#x27;],        // 自动解析目录下的 index 文件  &#125;,&#125;;\n(2) 顶层 await\n\nESM 中支持顶层 await（无需包裹在异步函数中）：\n// app.mjsconst data = await fetchData(); // 直接使用\n\n(3) 默认严格模式\n\nESM 中代码默认启用严格模式（无需 &quot;use strict&quot;）。\n\n4. CommonJS VS ES Modules在 Node.js 中，require() 和 import 是两种不同的模块系统（CommonJS 和 ES Modules），它们的加载机制有本质区别。以下是两个模块系统的比较：\n4.1 require() 是同步的，无法直接加载 ES 模块\nCommonJS 的 require()  \n\n是同步阻塞的（模块加载完成后才会执行后续代码）。\n只能加载 .js、.json、.node 等文件，默认不支持 .mjs（ES 模块）。\n如果直接 require(&#39;./es-module.mjs&#39;) 会报错：Error [ERR_REQUIRE_ESM]: Must use import to load ES Module\n\n\nES Modules 的 import  \n\n是异步的（底层使用 Promise）。\n必须用于 .mjs 文件或 package.json 中声明 &quot;type&quot;: &quot;module&quot; 的 .js 文件。\n\n\n\n4.2 在 CommonJS 中加载 ES 模块的方法由于 require() 无法直接加载 ES 模块，Node.js 提供了两种解决方案：\n方法 1：动态 import() 函数（推荐）\n\nimport() 是 ES 模块的异步加载语法，返回一个 Promise，可在 CommonJS 中使用。\n\n示例：\nES 模块（被加载方）\n// es-module.mjsexport const hello = () =&gt; &quot;Hello from ES Module&quot;;\n\nCommonJS 文件（加载方）\n// commonjs-app.js(async () =&gt; &#123;  const esModule = await import(&#x27;./es-module.mjs&#x27;);  console.log(esModule.hello()); // 输出: &quot;Hello from ES Module&quot;&#125;)();\n\n方法 2：通过 module.createRequire 创建自定义 require（复杂场景）\n\n适用于需要动态控制模块加载路径的情况：// commonjs-app.jsimport &#123; createRequire &#125; from &#x27;module&#x27;;const require = createRequire(import.meta.url);// 此时 require 仍无法加载 ES 模块，但可以加载其他 CommonJS 模块const cjsModule = require(&#x27;./commonjs-module.js&#x27;);\n\n5. Node.js核心模块5.1 global对象Node.js中的全局对象，用来存储全局变量：\n\nglobal：Node.js全局对象（类似浏览器的window）\nglobalThis：ES标准全局对象名称，Node.js中等于global\n\n与浏览器 window 对象的区别\n\n\n\n特性\nNode.js global\n浏览器 window\n\n\n\n作用域\n整个 Node.js 进程\n当前浏览器标签页\n\n\n特有 API\nprocess, Buffer, __dirname\ndocument, location, alert\n\n\n模块系统影响\n受 CommonJS&#x2F;ESM 规则约束\n直接暴露全局变量\n\n\n5.2 __dirname全局变量__dirname 是 Node.js 中的一个 全局变量，表示 当前执行脚本所在的目录的绝对路径。它是 CommonJS 模块系统的一部分，在 ES Modules（import/export）中不能直接使用。\n基本用法:\nconsole.log(__dirname);// 输出示例（Windows）: &#x27;C:\\\\Users\\\\yourname\\\\project\\\\src&#x27;// 输出示例（Linux/macOS）: &#x27;/home/yourname/project/src&#x27;\n\n始终返回 当前文件的目录路径（绝对路径）。\n不受 process.cwd()（工作目录）影响。\n\n __dirname 在 ES Modules 中的替代方案:\n在 ES Modules（import/export）中，__dirname 不可用，需要使用以下方式替代：\n替代方案 ：import.meta.url + fileURLToPath\nimport &#123; fileURLToPath &#125; from &#x27;node:url&#x27;;import &#123; dirname &#125; from &#x27;node:path&#x27;;// import.meta.url: 当前文件的 URL（ESM）const __filename = fileURLToPath(import.meta.url); // 获取当前文件的绝对路径const __dirname = dirname(__filename); // 提取目录部分console.log(__dirname); // 输出当前文件目录\n\n\n5.3 process模块process 是 Node.js 的一个核心全局对象，提供了与当前 Node.js 进程交互的多种功能和方法。它不需要通过 require() 导入即可使用。\nprocess 常用方法和属性\n\n\n\n分类\n属性&#x2F;方法\n类型\n说明\n示例\n\n\n\n进程信息\nprocess.pid\n属性\n当前进程的 PID\nconsole.log(process.pid); // 12345\n\n\n\nprocess.platform\n属性\n操作系统平台 (&#39;win32&#39;, &#39;linux&#39;, &#39;darwin&#39;)\nif (process.platform === &#39;win32&#39;) &#123; ... &#125;\n\n\n\nprocess.arch\n属性\nCPU 架构 (&#39;x64&#39;, &#39;arm&#39;)\nconsole.log(process.arch); // &#39;x64&#39;\n\n\n命令行参数\nprocess.argv\n属性（数组）\n命令行参数（[node路径, 脚本路径, ...args]）\nnode app.js arg1 → process.argv[2] === &#39;arg1&#39;\n\n\n环境变量\nprocess.env\n属性（对象）\n环境变量对象\nconsole.log(process.env.NODE_ENV); // &#39;development&#39;\n\n\n进程控制\nprocess.exit([code])\n方法\n退出进程（默认 code=0，非 0 表示失败）\nif (err) process.exit(1);\n\n\n5.4 path模块用于处理文件和目录路径的核心模块：\n常用方法：\n\npath.join([...paths])：将多个路径片段合并成一个路径\npath.resolve([...paths])：将多个路径片段解析成一个绝对路径\npath.basename(path)：返回路径的最后一部分\npath.dirname(path)：返回路径的目录部分\npath.extname(path)：返回文件的扩展名\npath.parse(path);: 解析路径\n\n示例：\n// const path = require(&#x27;path&#x27;);const path = require(&#x27;node:path&#x27;)// 合并路径const fullPath = path.join(&#x27;folder&#x27;, &#x27;subfolder&#x27;, &#x27;file.txt&#x27;);console.log(fullPath);  // folder/subfolder/file.txt// 获取绝对路径path.resolve(__dirname, &#x27;./m1.js&#x27;) // 获取文件名console.log(path.basename(&#x27;/home/user/file.txt&#x27;));  // file.txt// 获取文件扩展名console.log(path.extname(&#x27;index.html&#x27;));  // .html// 解析路径const pathObj = path.parse(&#x27;/public/images/logo.png&#x27;);console.log(pathObj);/*&#123;  root: &#x27;/&#x27;,  dir: &#x27;/public/images&#x27;,  base: &#x27;logo.png&#x27;,  ext: &#x27;.png&#x27;,  name: &#x27;logo&#x27;&#125;*/\n\n注意：\n\n工作目录(cwd)可能因执行方式不同而变化：\n\nVS Code调试执行：项目根目录\n\n命令行执行：当前脚本所在目录\n\n\n\nrequire(&#39;path&#39;) 和 require(&#39;node:path&#39;)\n\n\n\n方式\n含义\n是否强制加载核心模块\nNode.js 版本要求\n\n\n\nrequire(&#39;path&#39;)\n传统方式引入 path 模块\n可能被同名第三方模块覆盖\n所有版本\n\n\nrequire(&#39;node:path&#39;)\n显式引入 Node.js 核心 path 模块\n确保加载核心模块\nNode.js ≥ 14.18.0\n\n\n\n\n5.5 fs模块用于与文件系统交互，可以进行文件的读取、写入、删除等操作。提供同步&#x2F;异步API：\n常用方法：\n\nfs.readFile(path[, options], callback) - 读取文件\nfs.appendFile(path, data[, options], callback) - 追加内容\nfs.mkdir(path[, options], callback) - 创建目录\nfs.rm(path[, options], callback) - 删除文件&#x2F;目录\nfs.rename(oldPath, newPath, callback) - 重命名&#x2F;移动\nfs.copyFile(src, dest[, mode], callback) - 复制文件\n\n示例1：\nconst fs = require(&#x27;fs&#x27;);// 异步读取文件fs.readFile(&#x27;example.txt&#x27;, &#x27;utf8&#x27;, (err, data) =&gt; &#123;  if (err) &#123;    console.error(err);  &#125; else &#123;    console.log(data);  &#125;&#125;);// 同步读取文件const data = fs.readFileSync(&#x27;example.txt&#x27;, &#x27;utf8&#x27;);console.log(data);// 写入文件fs.writeFile(&#x27;example.txt&#x27;, &#x27;An apple a day&#x27;, err =&gt; &#123;  if (err) console.error(err);  else console.log(&#x27;成功写入文件!&#x27;);&#125;);\n\n示例2：\nconst fs = require(&#x27;fs/promises&#x27;) // Promise版本（推荐使用）// 异步读取文件（推荐）async function readFile() &#123;  try &#123;    const buffer = await fs.readFile(path.resolve(__dirname, &#x27;./readme.txt&#x27;))    console.log(buffer.toString())  &#125; catch (error) &#123;    console.error(error)  &#125;&#125;\n\n\n\n5.6 HTTP模块用于创建 HTTP 服务和客户端请求，处理 Web 服务器相关的操作。\n常用方法：\n\nhttp.createServer(callback)：创建一个 HTTP 服务器\nhttp.get(options, callback)：发起 HTTP GET 请求\nhttp.request(options, callback)：发起 HTTP 请求（支持更多方法，如 POST）\nrequest.method：获取HTTP 方法（GET, POST, PUT 等）\nrequest.url：获取请求的 URL（不包括域名）\nrequest.headers：获取请求头（对象形式）\nrequest.on(&#39;data&#39;, callback)： 接收请求体数据（POST/PUT）\nrequest.on(&#39;end&#39;, callback)：请求体接收完毕\nrequest.pipe(destination)\t：将请求数据流式传输到其他流\nresponse.setHeader(name, value)：设置单个响应头\nresponse.writeHead(statusCode, headers)：设置状态码和多个响应头\nresponse.write(data)：向客户端响应数据\nresponse.statusCode：设置状态码（默认 200）\nresponse.end()：结束响应\n\n示例1：\nconst http = require(&#x27;node:http&#x27;);// 创建一个简单的 HTTP 服务器http.createServer((req, res) =&gt; &#123;  const &#123; url, method &#125; = req;  if (url === &#x27;/&#x27; &amp;&amp; method === &#x27;GET&#x27;) &#123;    res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/plain&#x27; &#125;);    res.end(&#x27;Home Page&#x27;);  &#125; else if (url === &#x27;/api&#x27; &amp;&amp; method === &#x27;GET&#x27;) &#123;    res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;application/json&#x27; &#125;);    res.end(JSON.stringify(&#123; data: &#x27;API Response&#x27; &#125;));  &#125; else &#123;    res.writeHead(404, &#123; &#x27;Content-Type&#x27;: &#x27;text/plain&#x27; &#125;);    res.end(&#x27;Not Found&#x27;);  &#125;&#125;).listen(3000, () =&gt; &#123;  console.log(&#x27;Server running on http://localhost:3000&#x27;);&#125;);// 发起 GET 请求（客户端行为）http.get(&#x27;http://www.example.com&#x27;, (res) =&gt; &#123;  let data = &#x27;&#x27;;  res.on(&#x27;data&#x27;, chunk =&gt; data += chunk);  res.on(&#x27;end&#x27;, () =&gt; console.log(data));&#125;);\n\n示例2：\nconst http = require(&#x27;node:http&#x27;);// 配置请求const options = &#123;  hostname: &#x27;example.com&#x27;, // 目标主机  port: 80,               // 端口（HTTP默认80）  path: &#x27;/api/data&#x27;,      // 请求路径  method: &#x27;POST&#x27;,         // HTTP方法  headers: &#123;              // 请求头    &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,    &#x27;Authorization&#x27;: &#x27;Bearer token123&#x27;  &#125;&#125;;// 发起请求并处理响应const req = http.request(options, (res) =&gt; &#123;  let responseData = &#x27;&#x27;;  // 接收数据片段  res.on(&#x27;data&#x27;, (chunk) =&gt; &#123;    responseData += chunk;  &#125;);  // 响应结束  res.on(&#x27;end&#x27;, () =&gt; &#123;    console.log(&#x27;响应结果:&#x27;, responseData);  &#125;);  // 错误处理  res.on(&#x27;error&#x27;, (err) =&gt; &#123;    console.error(&#x27;响应错误:&#x27;, err);  &#125;);&#125;);// 写入请求体（如POST数据）req.write(JSON.stringify(&#123; key: &#x27;value&#x27; &#125;));// 超时控制req.setTimeout(5000, () =&gt; &#123;  req.destroy(); // 超时后终止请求  console.log(&#x27;请求超时&#x27;);&#125;);// 表示请求结束（必须调用）req.end();\n\n\n\n5.7 events 模块用于实现事件驱动的编程模型，可以创建自定义事件并监听触发。\n常用方法：\n\nEventEmitter.emit(eventName, [...args])：触发事件\nEventEmitter.on(eventName, listener)：监听事件\nEventEmitter.once(eventName, listener)：监听一次事件\n\n示例：\nconst EventEmitter = require(&#x27;events&#x27;);// 创建事件发射器class MyEmitter extends EventEmitter &#123;&#125;const myEmitter = new MyEmitter();// 监听事件myEmitter.on(&#x27;event&#x27;, () =&gt; &#123;  console.log(&#x27;Event was triggered!&#x27;);&#125;);// 触发事件myEmitter.emit(&#x27;event&#x27;);// 只监听一次myEmitter.once(&#x27;one-time&#x27;, () =&gt; &#123;    console.log(&#x27;This will only run once&#x27;);&#125;);myEmitter.emit(&#x27;one-time&#x27;);myEmitter.emit(&#x27;one-time&#x27;); // 不会触发\n\n\n\n5.8 os 模块模块提供了与操作系统相关的实用方法和属性。\n常用方法：\n\nos.platform()：返回操作系统平台\nos.cpus()：返回操作系统的 CPU 信息\nos.totalmem()：返回系统的总内存\nos.freemem()：返回系统的可用内存\n\n示例：\nconst os = require(&#x27;os&#x27;);console.log(&#x27;Platform:&#x27;, os.platform());  // linux, win32, darwin等console.log(&#x27;CPU Info:&#x27;, os.cpus());console.log(&#x27;Total Memory:&#x27;, os.totalmem());console.log(&#x27;Free Memory:&#x27;, os.freemem());\n\n\n\n5.9 url 模块用于解析和处理 URL，方便提取和操作 URL 中的各个部分。\n常用方法：\n\nurl.parse(urlString)：解析 URL 字符串，返回 URL 对象\nurl.format(urlObject)：将 URL 对象转换为字符串\nurl.resolve(from, to)：将相对路径转换为绝对路径\n\n示例：\nconst url = require(&#x27;url&#x27;);const myUrl = new URL(&#x27;https://example.com:8080/path/name?query=string#hash&#x27;);console.log(&#x27;Protocol:&#x27;, myUrl.protocol); // https:console.log(&#x27;Host:&#x27;, myUrl.host); // example.com:8080console.log(&#x27;Hostname:&#x27;, myUrl.hostname); // example.comconsole.log(&#x27;Port:&#x27;, myUrl.port); // 8080console.log(&#x27;Pathname:&#x27;, myUrl.pathname); // /path/nameconsole.log(&#x27;Search:&#x27;, myUrl.search); // ?query=stringconsole.log(&#x27;Hash:&#x27;, myUrl.hash); // #hashconsole.log(&#x27;Query:&#x27;, myUrl.searchParams.get(&#x27;query&#x27;)); // string// 解析 URL 字符串const parsedUrl = url.parse(&#x27;https://example.com/path?query=string&#x27;);console.log(parsedUrl);// 格式化 URL 对象const urlObject = &#123;    protocol: &#x27;https&#x27;,    host: &#x27;example.com&#x27;,    pathname: &#x27;/path&#x27;,    query: &#123; search: &#x27;string&#x27; &#125;&#125;;console.log(url.format(urlObject)); // https://example.com/path?search=string\n\n\n\n5.9 crypto 模块用于提供加密功能，可以进行数据加密、解密、哈希等操作。\n常用方法：\n\ncrypto.createHash(algorithm)：创建哈希实例\ncrypto.createCipheriv(algorithm, key, iv)：创建加密实例\ncrypto.createDecipheriv(algorithm, key, iv)：创建解密实例\n\n示例：\nconst crypto = require(&#x27;crypto&#x27;);// 创建哈希实例const hash = crypto.createHash(&#x27;sha256&#x27;);hash.update(&#x27;Hello World&#x27;);console.log(hash.digest(&#x27;hex&#x27;));  // 输出哈希值// 创建加密实例const key = crypto.randomBytes(32);const iv = crypto.randomBytes(16);const cipher = crypto.createCipheriv(&#x27;aes-256-cbc&#x27;, key, iv);let encrypted = cipher.update(&#x27;Hello World&#x27;, &#x27;utf8&#x27;, &#x27;hex&#x27;);encrypted += cipher.final(&#x27;hex&#x27;);console.log(encrypted);\n\n\n\n使用说明在 Node.js 中，核心模块（如 fs、path、http 等）在 CommonJS 和 ES Modules 两种模块系统中都可以直接调用，但具体使用方式略有差异。以下是详细说明：\n(1) 默认导出的差异\n\nCommonJS 中，核心模块通常导出完整的对象：\nconst fs = require(&#x27;fs&#x27;);fs.readFileSync(...);\nES Modules 中，部分核心模块可能提供命名导出（但大多数仍为默认导出）：\nimport &#123; readFileSync &#125; from &#x27;fs&#x27;; // 命名导出（部分支持）import fs from &#x27;fs&#x27;;               // 默认导出（通用）\n\n(2) 动态 require() 在 ES Modules 中不可用\n\n在 ES Modules 文件中，不能直接使用 require()（除非通过 createRequire 创建）：// ES Module 文件中（会报错）const fs = require(&#x27;fs&#x27;); // Error: require is not defined\n必须用 import：import fs from &#x27;fs&#x27;;\n\n6. 总结在 Node.js 的生态系统中，模块系统经历了从 CommonJS 到 ES Modules 的演进，每种方式都有其独特的特点和适用场景。\n\n\n\n特性\nES Modules\nCommonJS\n\n\n\n语法\nimport/export\nrequire/module.exports\n\n\n加载方式\n静态（编译时分析）\n动态（运行时加载）\n\n\n浏览器支持\n原生支持\n需打包工具（如 Webpack）\n\n\nNode.js 支持\n.mjs 或 &quot;type&quot;: &quot;module&quot;\n默认支持 .js\n\n\n顶层 await\n支持\n不支持\n\n\n适用场景\n浏览器环境和静态优化\n服务端文件系统 I&#x2F;O\n\n\n参考\nModules: CommonJS modules\nFolders as Modules\nESM 和 CommonJS 的互操作\nNode.js 官方文档\n\n","categories":["Node.js","JavaScript 进阶"],"tags":["模块化","CommonJS","ES Modules"]}]
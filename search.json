[{"title":"JavaScript异步编程：从回调到Promise","url":"/2023/08/03/Promise/","content":"什么是异步先来看下面这样一个关于时间规划的小学数学题：\n\n题目：四年级小敏每天起床后要做的事情有：穿衣（3分钟），整理床铺（2分钟），洗脸梳头（8分钟），上厕所（5分钟），烧饭（20分钟），吃早饭（12分钟），完成这些工作要50分钟。你认为最合理的安排是多少分钟？\n答案：6:00 起床├─ 6:00-6:03 穿衣（3分钟）├─ 6:03-6:05 整理床铺（2分钟）├─ 6:05-6:25 烧饭（20分钟）│   ├─ 6:05-6:13 洗脸梳头（8分钟） ← 和烧饭完全重叠│   ╰─ 6:13-6:18 上厕所（5分钟）   ← 也在烧饭期间完成╰─ 6:25-6:30 吃早饭（5分钟）\n\n题目很简单，我们也能很快的想到答案，烧饭是一件很耗时且不需要太多人工参与的事情，我们就可以利用这段时间去处理其他事情。但这和异步有什么关系呢？\n可以简单的说，像题目中这样：在同一时间段内，可以同时处理多件事情，不需要等前一个事情处理完成，才能处理下一个的场景，就是异步。在同一时间段内，只能处理一件事情，需要等待前一个事情处理完成后，才能开始处理下一个事情的场景，就是同步。\n在程序的世界里，也存在许多类似于烧饭的处理，例如：文件的I&#x2F;O处理、数据库操作等。在同步代码中，当一个任务（如读取文件、数据库查询）执行时，整个线程会被阻塞，无法处理其他请求，导致CPU空闲等待。这不仅会影响到用户的体验，还造成资源的浪费。\n而JavaScript 是单线程语言，同一时间只能执行一个任务，那该如何解决这个问题呢？\n怎么实现异步回调函数有人可能会想到，我们可以使用回调函数来实现异步。例如：\n// 代码中用毫秒代替分钟setTimeout(() =&gt; &#123;    console.log(&quot;6:05-6:13 洗脸梳头（8分钟）&quot;);        setTimeout(() =&gt; &#123;        console.log(&quot;6:13-6:18 上厕所（5分钟）&quot;);        // 烧饭完成后        setTimeout(() =&gt; &#123;            console.log(&quot;6:25 饭烧好了&quot;);        &#125;, 20 - 5 - 8); // 烧饭时间减去已经过去的时间            &#125;, 8); // 洗脸梳头8分钟    &#125;, 5); // 穿衣+整理床铺共5分钟/*输出：    6:05-6:13 洗脸梳头（8分钟）    6:13-6:18 上厕所（5分钟）    6:25 饭烧好了*/\n\n但如果使用回调函数来描述整个场景呢？\nconsole.log(&quot;6:00 起床&quot;);setTimeout(() =&gt; &#123;    console.log(&quot;6:00-6:03 穿衣（3分钟）&quot;);    setTimeout(() =&gt; &#123;        console.log(&quot;6:03-6:05 整理床铺（2分钟）&quot;);        console.log(&quot;6:05-6:25 开始烧饭（20分钟）&quot;);        // 在烧饭期间并行执行其他任务        setTimeout(() =&gt; &#123;            console.log(&quot;6:05-6:13 洗脸梳头（8分钟）&quot;);                            setTimeout(() =&gt; &#123;                console.log(&quot;6:13-6:18 上厕所（5分钟）&quot;);                                // 烧饭完成后                setTimeout(() =&gt; &#123;                    console.log(&quot;6:25 饭烧好了&quot;);                                        setTimeout(() =&gt; &#123;                        console.log(&quot;6:25-6:30 吃早饭（5分钟）&quot;);                        console.log(&quot;6:30 所有任务完成&quot;);                    &#125;, 5); // 5分钟吃早饭                &#125;, 20 - 13); // 烧饭总时间减去已经过去的时间            &#125;, 8); // 穿衣+整理床铺+洗脸梳头共13分钟        &#125;, 5); // 穿衣+整理床铺共5分钟    &#125;, 2); // 整理床铺2分钟&#125;, 3); // 穿衣3分钟/*输出：\t6:00 起床    6:00-6:03 穿衣（3分钟）    6:03-6:05 整理床铺（2分钟）    6:05-6:25 开始烧饭（20分钟）    6:05-6:13 洗脸梳头（8分钟）    6:13-6:18 上厕所（5分钟）    6:25 饭烧好了    6:25-6:30 吃早饭（5分钟）    6:30 所有任务完成*/\n\n可以看到，函数嵌套的过深，不仅影响了代码的可读性，还会难以调试和维护。在JavaScript异步编程中，这种多层嵌套回调函数形成的复杂代码结构被称为回调地狱（Callback Hell）。\n\n回调地狱（Callback Hell），也称为金字塔厄运（Pyramid of Doom），是指 JavaScript 中由于多层嵌套回调函数导致的代码结构复杂、难以维护的现象。\n带来的问题：\n​\t① 代码可读性差\n​\t② 错误处理复杂\n​\t③ 调试困难\n​\t……\n\n但在实际的开发中，我们不可避免的会遇到这种复杂的业务场景，该怎么解决回调地狱的问题呢？\nPromiseJavaScript中的一种异步编程模式，解决了回调地狱的问题，帮助开发者更清晰地处理异步操作，使代码更易读、易维护。\n核心原理与工作机制Promise 本质上是一个内置构造函数，用于创建 Promise 对象实例。每个 Promise 实例内部维护着两个关键属性：\n\nPromiseState（状态机）：\n\npending：初始状态，表示异步操作正在进行中\nfulfilled：操作成功完成（通过 resolve() 触发）\nrejected：操作失败或被拒绝（通过 reject() 或抛出异常触发）\n\n\nPromiseResult（结果容器）：\n\n存储异步操作的返回值（resolve 传入的值）\n或存储错误信息（reject 传入的错误对象）\n\n\n\n状态转换规则：\n\n创建时自动初始化为 pending 状态\n通过 resolve(value) 转换为 fulfilled，并存储结果值\n通过 reject(reason) 或抛出异常转换为 rejected，并存储错误信息\n状态转换是单向且不可逆的，一旦确定就不可更改\n\n执行流程：\n\n实例化 Promise 时，执行器函数（executor）立即执行\n通过 then() 方法注册回调：\n当状态变为 fulfilled，触发第一个回调函数\n当状态变为 rejected，触发第二个回调函数（或 catch()）\n\n\n通过 finally() 注册最终回调（无论成功失败都会执行）\n\n优点\n避免回调地狱\n链式调用\n错误处理更简单\n…..\n\n基本用法/*\t1. 创建一个 Promise 对象\t创建Promise时，构造函数接收一个执行器函数，在函数里写具体的处理逻辑，\t函数中有两个参数resolve/reject，这两个参数也是方法，在操作完成时调用。\t· resolve(value)：当异步操作成功时调用，存储成功信息。\t· reject(reason)：当异步操作失败时调用，存储错误信息。*/const myPromise = new Promise((resolve, reject) =&gt; &#123;\t// 异步操作......    if(condition) &#123;\t// 处理成功        resolve(&quot;成功！&quot;);\t// 调用 resolve    &#125; else &#123;\t// 处理失败        reject(&quot;失败！&quot;); // 调用 reject    &#125;&#125;);/*\t2. 使用 then/catch/finally 处理执行结果        then(result): Promise成功时执行            - 接收成功结果            - 可返回新值（成为新Promise的resolve值）            - 可链式调用        catch(error): Promise失败时执行\t            - 专门处理错误            - 可捕获前面所有then中的错误            - 也能返回新值        finally(): 无论成功失败都执行\t            - 不接收参数            - 通常放在最后，用于清理操作            - 不影响Promise链的最终值*/myPromise  .then((result) =&gt; &#123;    console.log(&quot;成功结果:&quot;, result);    return &quot;新的值&quot;; // 可传递给下一个then  &#125;)  .catch((error) =&gt; &#123;    console.error(&quot;失败原因:&quot;, error);    throw new Error(&quot;处理错误&quot;); // 可继续抛出错误  &#125;)  .finally(() =&gt; &#123;    console.log(&quot;无论成功失败都会执行&quot;);  &#125;);\n\n核心特点\n\n\n特性\n说明\n\n\n\n状态不可逆\npending → fulfilled（成功）或 rejected（失败）\n\n\n链式调用\n.then() 返回新的 Promise，可继续 .then()\n\n\n错误冒泡\n错误会一直传递到最近的 .catch()\n\n\n微任务队列\nPromise 回调属于微任务（比 setTimeout 宏任务优先级高）\n\n\n常用方法以下是 Promise 静态方法的对比汇总表格：\n\n\n\n方法\n描述\n成功条件\n失败条件\n返回值\n特点\n\n\n\nPromise.resolve()\n创建立即完成的Promise\n总是成功\n无\n传入的值\n快速包装值为Promise\n\n\nPromise.reject()\n创建立即拒绝的Promise\n无\n总是失败\n传入的错误\n快速创建拒绝的Promise\n\n\nPromise.all()\n处理多个Promise\n所有Promise成功\n任意一个失败\n结果数组（按输入顺序）\n一个失败立即拒绝，不等待其他\n\n\nPromise.allSettled()\n处理多个Promise\n所有Promise完成（无论成功失败）\n不会失败\n状态对象数组：&#123;status: &#39;fulfilled&#39;, value&#125;&#123;status: &#39;rejected&#39;, reason&#125;\n等待所有Promise最终状态\n\n\nPromise.race()\n处理多个Promise\n第一个完成的Promise（成功&#x2F;失败）\n第一个失败的Promise\n第一个完成的结果\n只关心最先完成的结果\n\n\nPromise.any()\n处理多个Promise\n任意一个Promise成功\n全部Promise失败\n第一个成功的结果\n忽略拒绝，只取第一个成功值\n\n\n示例代码：\n// Promise.allPromise.all([p1, p2]).then(results =&gt; &#123;  console.log(&#x27;所有成功:&#x27;, results); // [v1, v2]&#125;).catch(err =&gt; &#123;  console.log(&#x27;首个失败:&#x27;, err);&#125;);// Promise.allSettledPromise.allSettled([p1, p2]).then(results =&gt; &#123;  results.forEach(result =&gt; &#123;    if (result.status === &#x27;fulfilled&#x27;) &#123;      console.log(&#x27;成功:&#x27;, result.value);    &#125; else &#123;      console.log(&#x27;失败:&#x27;, result.reason);    &#125;  &#125;);&#125;);// Promise.racePromise.race([p1, p2]).then(winner =&gt; &#123;  console.log(&#x27;首个完成:&#x27;, winner);&#125;);// Promise.anyPromise.any([p1, p2]).then(firstSuccess =&gt; &#123;  console.log(&#x27;首个成功:&#x27;, firstSuccess);&#125;).catch(err =&gt; &#123;  console.log(&#x27;全部失败:&#x27;, err.errors); // AggregateError&#125;);\n\n使用场景建议：\n\n全成功才继续：用 Promise.all\n收集所有结果：用 Promise.allSettled\n竞速响应：用 Promise.race\n任一成功即可：用 Promise.any\n\n重构时间规划问题// 创建一个延迟执行的 Promise 辅助函数function delay(taskName, minutes) &#123;  return new Promise(resolve =&gt; &#123;    setTimeout(() =&gt; &#123;      console.log(`$&#123;taskName&#125;（$&#123;minutes&#125;分钟）`);      resolve();    &#125;, minutes); // 用毫秒代替分钟，便于演示  &#125;);&#125;// 主流程开始console.log(&quot;6:00 起床&quot;);// 穿衣delay(&quot;6:00-6:03 穿衣&quot;, 3)  .then(() =&gt; &#123;    // 整理床铺    return delay(&quot;6:03-6:05 整理床铺&quot;, 2);  &#125;)  .then(() =&gt; &#123;    console.log(&quot;6:05-6:25 开始烧饭（20分钟）&quot;);        // 烧饭主任务    const cooking = delay(&quot;6:25 饭烧好了&quot;, 20);        // 并行任务1: 洗脸梳头    const faceWashing = delay(&quot;6:05-6:13 洗脸梳头&quot;, 8);        // 并行任务2: 上厕所（在洗脸梳头之后）    const toilet = faceWashing.then(() =&gt; delay(&quot;6:13-6:18 上厕所&quot;, 5));        // 等待所有并行任务完成    return Promise.all([cooking, toilet]);  &#125;)  .then(() =&gt; &#123;    // 吃早饭    return delay(&quot;6:25-6:30 吃早饭&quot;, 5);  &#125;)  .then(() =&gt; &#123;    console.log(&quot;6:30 所有任务完成&quot;);  &#125;)  .catch(error =&gt; &#123;    console.error(&quot;流程出错:&quot;, error);  &#125;);\n\n虽然通过链式调用可以解决回调地狱的问题，但是我们还是可以看到then()中嵌套then()的现象，代码的可读性还是不够好。\nasync&#x2F;await是什么？async&#x2F;await 是 ES2017 引入的语法糖，基于 Promise 的异步编程解决方案，让异步代码拥有同步代码的书写方式。\n核心本质：\n\nasync：将函数标记为异步，总是返回 Promise 对象\nawait：暂停异步函数执行，等待 Promise 解决\n\n用法通过async可以来创建一个异步函数，async函数会返回一个Promise对象。\n1. 声明异步函数async function fetchData() &#123;  return &#x27;data&#x27;; // 自动包装为 resolved Promise&#125;// 等价于function fetchData() &#123;  return Promise.resolve(&#x27;data&#x27;);&#125;\n\n2. 等待异步结果async function getUser() &#123;  const response = await fetch(&#x27;/api/user&#x27;); // 等待Promise解决  const data = await response.json(); // 再次等待  return data;&#125;\n\n注意事项1.使用范围await只能在async函数中使用，或ES模块的顶层作用域中使用。await阻塞的只是异步函数内部的代码，不会影响外部代码。\n\nES模块的顶层作用域是什么？\nES模块的顶层作用域指的是在模块的最外层，不在任何函数或类内部的代码块。这种情况下，顶层作用域的代码会在模块加载时立即执行。\n\nhtml中：\n\n&lt;script type=&quot;module&quot;&gt;    await Promise.resolve().then(() =&gt; console.log(&quot;Hello&quot;));&lt;/script&gt;\n2. 错误处理通过await调用异步代码时，需要通过try…catch来捕获异常\n// 方式1：try/catchasync function fetchWithTryCatch() &#123;  try &#123;    const data = await fetchData();  &#125; catch (err) &#123;    console.error(&#x27;捕获错误:&#x27;, err);  &#125;&#125;// 方式2：catch回调async function fetchWithCatch() &#123;  const data = await fetchData().catch(err =&gt; &#123;    console.error(&#x27;捕获错误:&#x27;, err);  &#125;);&#125;\n\n3. 并行优化// 错误：顺序执行（耗时较长）async function sequential() &#123;  const a = await fetchA(); // 等待完成  const b = await fetchB(); // 才开始&#125;// 正确：并行执行async function parallel() &#123;  const [a, b] = await Promise.all([fetchA(), fetchB()]);&#125;\n\n常见陷阱\n忘记await：导致后续代码使用未resolved的Promise\nasync function demo() &#123;  const data = fetchData(); // 缺少await！  console.log(data); // 输出: Promise &#123;&lt;pending&gt;&#125;&#125;\n\n不必要await：同步操作无需await\nasync function unnecessary() &#123;  await console.log(&#x27;这不需要await&#x27;); // 反模式&#125;\n\n循环中使用：可能需要重构为for…of顺序执行\nasync function processArray(array) &#123;  for (const item of array) &#123; // 替代forEach/map    await processItem(item);  &#125;&#125;\n\n重构时间规划问题// 辅助函数：模拟延迟执行并记录时间async function delay(taskName, minutes) &#123;    return new Promise(resolve =&gt; &#123;        setTimeout(() =&gt; &#123;            console.log(`$&#123;taskName&#125;（$&#123;minutes&#125;分钟）`);            resolve();        &#125;, minutes); // 用毫秒代替分钟，便于演示    &#125;);&#125;// 主流程async function morningRoutine() &#123;    console.log(`6:00 起床`);    // 顺序执行穿衣和整理床铺    await delay(&quot;6:00-6:03 穿衣&quot;, 3);    await delay(&quot;6:03-6:05 整理床铺&quot;, 2);    // 开始烧饭并并行执行其他任务    console.log(`6:05 开始烧饭（20分钟）`);    // 并行执行的任务    const tasks = [        // 洗脸梳头（8分钟）和上厕所（5分钟）的链式调用        (async () =&gt; &#123;            // 洗脸梳头（8分钟）            await delay(&quot;6:05-6:13 洗脸梳头&quot;, 8);// 上厕所（5分钟）            return await delay(&quot;6:13-6:18 上厕所&quot;, 5);        &#125;)(),        // 烧饭任务（20分钟）        delay(&quot;6:25 饭烧好了&quot;, 20)    ];    await Promise.all(tasks);    // 吃早饭    await delay(&quot;6:25-6:30 吃早饭&quot;, 5);    console.log(&quot;6:30 所有任务完成&quot;);&#125;// 执行流程morningRoutine().catch(err =&gt; console.error(&quot;流程出错:&quot;, err));\n\nJS是单线程的，那么它是如何实现异步处理的呢？\n在深入探讨解决方案之前，让我们先理解一个概念：事件循环（Event Loop）。JavaScript 通过事件循环（Event Loop）机制，在保持单线程执行模型的同时，实现了异步操作的高效处理。下面我们将详细解析这一重要机制。\n原理：事件循环（Event Loop）事件循环是JavaScript中的一个的运行时模型，负责程序执行期间的资源管理、任务处理和协调操作，它定义了代码如何被调度和执行的。\n关键组件\n\n\n组件\n说明\n常见例子\n\n\n\n调用栈（Call Stack）\n同步代码的执行栈，遵循后进先出（LIFO）。若栈溢出（如无限递归）会报错。\n同步代码（如 console.log）、函数调用\n\n\n任务队列（Task Queue）\n即宏任务队列，是事件循环中处理”常规”异步任务的队列。\nsetTimeout、setInterval、DOM事件、I&#x2F;O（如 fs.readFile）\n\n\n微任务队列（Microtask Queue）\n存放微任务，每轮事件循环结束后立即清空，优先级高于宏任务。\nPromise.then、MutationObserver、queueMicrotask、process.nextTick。\n\n\n事件循环(Event Loop)关键组件示意图\nflowchart TD\n    subgraph 队列\n        direction LR\n        subgraph 任务队列_宏任务队列[\"任务队列（宏任务队列）\"]\n            H[setTimeout]\n            I[setInterval]\n            J[DOM事件]\n            K[I/O回调]\n        end\n        \n        subgraph 微任务队列[\"微任务队列\"]\n            E[Promise.then]\n            F[queueMicrotask]\n            G[MutationObserver]\n        end\n    end\n    \n    subgraph 调用栈[\"调用栈\"]\n        A[全局执行上下文] --> B[函数1]\n        B --> C[函数2]\n        C --> D[console.log]\n    end\n执行流程简化的执行顺序：1. 同步代码 → 2. 微任务 → 3. 宏任务\n\n调用栈检查阶段\n事件循环首先检查调用栈(Call Stack)状态\n若调用栈不为空，则继续执行栈中的同步代码\n若调用栈为空，则进入任务队列处理阶段\n\n\n微任务处理阶段\n当调用栈清空后，事件循环会优先处理微任务队列(Microtask Queue)\n依次执行微任务队列中的所有任务，直到队列完全清空\n\n\n宏任务处理阶段\n在微任务队列清空后，从宏任务队列(Macrotask Queue)中取出一个任务执行\n执行完毕后立即返回微任务检查阶段\n\n\n\n上述过程形成持续的事件循环(Event Loop)，每次宏任务执行后都会重新检查微任务队列，这种机制保证了高优先级任务的及时处理。\nflowchart TD\n    Start([开始]) --> Sync[执行同步代码]\n    Sync --> Micro{微任务队列空?}\n    Micro -->|否| ExecuteMicro[执行微任务] --> Micro\n    Micro -->|是| Macro{宏任务队列空?}\n    Macro -->|否| ExecuteMacro[执行宏任务] --> Sync\n    Macro -->|是| End([结束])\n\n\n\n提交主题源码到博客的 Git 仓库（假设主题在 themes&#x2F;redefine-dev&#x2F;）\ngit add themes&#x2F;redefine-dev&#x2F;git commit -m “更新主题代码”git push origin main\n","categories":["JavaScript"],"tags":["异步编程","回调","Promise"]}]
[{"title":"深入理解 Promise：从零实现一个符合规范的 Promise 类","url":"/2025/08/09/MyPromise/","content":"第1版：基础骨架核心功能\nPromise 对象有三种状态，它们之间的转换是不可逆的：\n\n\nPending（等待）：初始状态，既没有被兑现，也没有被拒绝\nFulfilled（已兑现）：意味着操作成功完成\nRejected（已拒绝）：意味着操作失败\n\n\n基本的resolve&#x2F;reject功能\n\nconst PROMISE_STATE = &#123;    PENDING: 0,    // 等待状态    FULFILLED: 1,  // 成功状态    REJECTED: 2    // 失败状态&#125;;class MyPromise &#123;    // 存储 Promise 的最终结果值（resolve 或 reject 传入的值）    #result;    // 跟踪 Promise 当前状态（PENDING/FULFILLED/REJECTED）    #state = PROMISE_STATE.PENDING;  // 初始状态    // 构造函数：接收一个“执行器”作为参数    constructor(executor) &#123;        // 调用回调函数        /*        \t注意，这里的写法一有问题，当使用方法一时，在#resolve和#reject中无法正确访问私有字段（如 #state、#result 等），            报错：Cannot read properties of undefined (reading &#x27;#state&#x27;)。原因如下：        \t1.this 指向丢失：当 #resolve 和 #reject 被直接作为参数传递时，它们会失去与当前Promise 实例的绑定            （this 会指向 undefined 或全局对象，严格模式下是 undefined）。            2.无法访问私有字段：由于 #resolve 和 #reject 是私有方法（以 # 开头），如果 this 指向不正确，            调用时会抛出错误，因为私有字段只能在类的内部访问。            写法二为什么正确？            bind(this) 确保 this 指向当前 Promise 实例，这样在 #resolve 和 #reject 内部可以正确访问            实例的私有字段（如 #state、#value 等）。        */        // 写法一：        // executor(this.#resolve, this.#resolve)        // 写法二：        executor(this.#resolve.bind(this), this.#reject.bind(this));        // 写法三（使用箭头函数）：        /*        \t在 JavaScript 中，箭头函数不会有自己的 this，它会捕获外部上下文中的 this。            因此，在这种写法中，箭头函数会使用当前上下文中的 this，也就是类的实例。            这确保了 this.#resolve 和 this.#reject 在执行时 this 始终指向正确的类实例。        */        // executor(value =&gt; this.#resolve(value), reason =&gt; this.#reject(reason));    &#125;\t// 用来存储成功的数据    #resolve(value) &#123;    \t// 保证状态只被设置一次，不可逆        if (this.#state !== PROMISE_STATE.PENDING) return;        this.#result = value;        this.#state = PROMISE_STATE.FULFILLED;    &#125;    // 用来存储错误的数据    #reject(reason) &#123;    \t// 保证状态只被设置一次，不可逆        if (this.#state !== PROMISE_STATE.PENDING) return;        this.#result = reason;        this.#state = PROMISE_STATE.REJECTED;    &#125;    // 添加一个用来读取数据的then方法    then(onFulfilled, onRejected) &#123;        if (this.#state === PROMISE_STATE.FULFILLED) &#123;            onFulfilled(this.#result);        &#125; else if (this.#state === PROMISE_STATE.REJECTED) &#123;            onRejected(this.#result);        &#125;    &#125;&#125;\n\n测试用例const mp = new MyPromise((resolve, reject) =&gt; &#123;    // resolve(1);\t// 正常输出    // reject(&#x27;error&#x27;); // 正常输出    setTimeout(() =&gt; &#123;resolve(&quot;111&quot;)&#125;, 1000); // 无输出&#125;);mp.then(    (result) =&gt; console.log(&quot;getResult: &quot;, result),\t(reason) =&gt; console.log(&quot;getReason: &quot;, reason));\n\n存在问题\n无法处理异步操作（setTimeout中的resolve）\nthen方法只能处理已确定的状态\n不支持链式调用\n\n第2版：支持异步回调问题分析1. 无法处理异步操作（如 setTimeout 中的 resolve）原因\nMyPromise 中的 then 方法只会在 Promise 的状态已经确定（即已经是 FULFILLED 或 REJECTED）时立即执行回调函数。但在 mp.then() 执行时，resolve(&quot;111&quot;) 还没有执行，state 还是 PROMISE_STATE.PENDING 状态，不满足if条件，所有没有任何输出。\n改进方案\n需要将 then 方法中的回调函数延迟执行，而不是在同步代码执行时立即执行。为此，使用一个队列来存储 then 的回调函数，当 Promise 状态变更时（即从 PENDING 变为 FULFILLED 或 REJECTED），依次调用这些回调函数。\n2. then 方法只能处理已确定的状态原因 在当前实现中，then 方法只处理 PENDING 状态之外的情况。对于 PENDING 状态，它没有做任何处理，这意味着 then 不能正确处理处于 PENDING 状态的 Promise。\n改进方案\n当 then 被调用时，如果 Promise 仍处于 PENDING 状态，应该将回调函数推入队列，等状态变为 FULFILLED 或 REJECTED 时再执行。\n改进版本const PROMISE_STATE = &#123;    PENDING: 0,    // 等待状态    FULFILLED: 1,  // 成功状态    REJECTED: 2    // 失败状态&#125;;class MyPromise &#123;    // 存储 Promise 的最终结果值（resolve 或 reject 传入的值）    #result;    // 跟踪 Promise 当前状态（PENDING/FULFILLED/REJECTED）    #state = PROMISE_STATE.PENDING;  // 初始状态    // 用于保存 then 的回调函数（支持链式调用）    #callbacks = [];    // 构造函数：接收一个“执行器”作为参数    constructor(executor) &#123;        // 调用回调函数        executor(this.#resolve.bind(this), this.#reject.bind(this));    &#125;    // 用来存储成功的数据    #resolve(value) &#123;        if (this.#state !== PROMISE_STATE.PENDING) return;        this.#result = value;        this.#state = PROMISE_STATE.FULFILLED;        // 异步执行回调        // 当 resolve 执行时，说明数据已经进来了，需要调用 then 中保存的回调函数        this.#executeCallbacks();    &#125;    // 用来存储错误的数据    #reject(reason) &#123;        // 保证状态只被设置一次，不可逆        if (this.#state !== PROMISE_STATE.PENDING) return;        this.#result = reason;        this.#state = PROMISE_STATE.REJECTED;        // 异步执行回调        // 当 resolve 执行时，说明数据已经进来了，需要调用 then 中保存的回调函数        this.#executeCallbacks();    &#125;    // 执行所有回调函数    #executeCallbacks() &#123;        for (const callback of this.#callbacks) &#123;            queueMicrotask(() =&gt; &#123;                callback(this.#result);            &#125;);        &#125;        this.#callbacks = [];  // 执行完清空回调队列    &#125;    then(onFulfilled, onRejected) &#123;        if (this.#state === PROMISE_STATE.FULFILLED) &#123;            // then 的回调函数，应该放入到微任务队列中执行，而不是直接调用            queueMicrotask(() =&gt; &#123;                onFulfilled(this.#result);            &#125;);        &#125; else if (this.#state === PROMISE_STATE.REJECTED) &#123;            // then 的回调函数，应该放入到微任务队列中执行，而不是直接调用            queueMicrotask(() =&gt; &#123;                onRejected(this.#result);            &#125;);        &#125; else &#123;            // 如果 Promise 处于 PENDING 状态，将回调放入队列            this.#callbacks.push(() =&gt; onFulfilled(this.#result));        &#125;    &#125;&#125;\n\n测试用例const p = new MyPromise((resolve, reject) =&gt; &#123;    setTimeout(() =&gt; resolve(&#x27;异步结果&#x27;), 1000 * 2);&#125;);// 2秒后输出两次&quot;异步结果&quot;p.then(res =&gt; &#123;    console.log(res);     return &quot;异步结果2&quot;;&#125;, error =&gt; &#123;    console.error(error)    return &quot;错误结果1&quot;&#125;);p.then(res =&gt; console.log(res), error =&gt; console.error(error));\n\n存在问题\n仍然不支持链式调用\n错误处理不完善\n没有处理then中回调函数的返回值\n\n第3版：完整链式调用问题分析1. 无法链式调用原因 目前的 then 方法没有返回新的 Promise 实例，这意味着每次调用 then 时都没有新的 Promise 返回，导致无法链式调用。链式调用需要 then 返回一个新的 Promise，这样下一个 then 就可以在之前的结果上继续执行。\n改进方案\n在 then 方法中返回一个新的 Promise，并且根据回调函数的执行结果来决定新 Promise 的状态。这确保了可以实现链式调用。\n2. 错误处理不完整原因\n当 onFulfilled 或 onRejected 回调抛出异常时，没有做任何处理。\n改进方案\n当 onFulfilled 或 onRejected 回调抛出异常时，应该返回一个新的 Promise，并使其变为 rejected 状态。\n3. 回调函数的正确传递原因\n回调函数被直接存储和执行，没有处理它们的返回值。\n改进方案\n在 then 的回调中返回一个新的 Promise，或者确保回调值正确传递给下一个 then。\n改进版本const PROMISE_STATE = &#123;    PENDING: 0,    FULFILLED: 1,    REJECTED: 2&#125;;class MyPromise &#123;    #result;    #state = PROMISE_STATE.PENDING;    #callbacks = [];    constructor(executor) &#123;        try &#123;            executor(this.#resolve.bind(this), this.#reject.bind(this));        &#125; catch (error) &#123;            this.#reject(error);        &#125;    &#125;    #resolve(value) &#123;        if (this.#state !== PROMISE_STATE.PENDING) return;        this.#result = value;        this.#state = PROMISE_STATE.FULFILLED;        this.#executeCallbacks();    &#125;    #reject(reason) &#123;        if (this.#state !== PROMISE_STATE.PENDING) return;        this.#result = reason;        this.#state = PROMISE_STATE.REJECTED;        this.#executeCallbacks();    &#125;    #executeCallbacks() &#123;        queueMicrotask(() =&gt; &#123;            for (const &#123; onFulfilled, onRejected, resolve, reject &#125; of this.#callbacks) &#123;                try &#123;                    if (this.#state === PROMISE_STATE.FULFILLED) &#123;                        const result = onFulfilled(this.#result);                        resolve(result);                    &#125; else if (this.#state === PROMISE_STATE.REJECTED) &#123;                        const result = onRejected(this.#result)                        reject(result);                    &#125;                &#125; catch (error) &#123;                    reject(error);                &#125;            &#125;            this.#callbacks = [];        &#125;);    &#125;    then(onFulfilled, onRejected) &#123;        return new MyPromise((resolve, reject) =&gt; &#123;            this.#callbacks.push(&#123;                onFulfilled,                onRejected,                resolve,                reject            &#125;);            // 如果状态已经确定，立即执行回调            if (this.#state !== PROMISE_STATE.PENDING) &#123;                this.#executeCallbacks();            &#125;        &#125;);    &#125;    catch(onRejected) &#123;        return this.then(null, onRejected);    &#125;&#125;\n\n测试用例const p = new MyPromise((resolve, reject) =&gt; &#123;    setTimeout(() =&gt; resolve(&#x27;异步结果&#x27;), 1000);&#125;);p.then(res =&gt; &#123;    console.log(res);  // 输出: 异步结果    return &#x27;新的结果&#x27;;&#125;).then(res =&gt; &#123;    console.log(res);  // 输出: 新的结果&#125;).catch(error =&gt; &#123;    console.error(error);&#125;);\n\n存在问题\n未处理 onFulfilled&#x2F;onRejected 不是函数的情况（值穿透）\n未实现静态方法（如 MyPromise.resolve&#x2F;MyPromise.reject）\n……\n\n关键点解析1. 为什么需要queueMicrotask？Promise的回调必须异步执行，且需要在当前脚本执行完成后立即执行。微任务队列正好满足：\n\n比setTimeout更快\n在浏览器渲染前执行\n确保执行顺序的可预测性\n\n2. 链式调用的核心then(onFulfilled) &#123;    return new Promise((resolve) =&gt; &#123;        // 将前一个Promise的结果处理后传递给下一个        this.#callbacks.push(() =&gt; &#123;            resolve(onFulfilled(this.#result));        &#125;);    &#125;);&#125;\n\n3. 错误处理机制try &#123;    const result = onFulfilled(this.#result);    resolve(result);&#125; catch (error) &#123;    // 捕获同步错误，传递给下一个reject    reject(error);&#125;\n\n总结本篇博客仅简单实现了一个 Promise，要完全符合 Promises&#x2F;A+ 规范还需要更多工作。这个过程极大地加深了我对 JavaScript 异步编程的理解，深入理解了以下的概念：\n\nPromise 的状态机制（pending&#x2F;fulfilled&#x2F;rejected）\n异步回调的处理（queueMicrotask 的使用）\n链式调用的实现原理\n\n参考\nPromises&#x2F;A+ 规范\nECMAScript Promise 标准\n\n","categories":["JavaScript","异步编程"],"tags":["异步编程","回调","Promise"]},{"title":"Docker 核心概念与基本使用","url":"/2025/08/23/docker-fundamentals/","content":"一、Docker 是什么？为什么需要它？在软件开发中，我们经常遇到这样的困境：“在我的机器上可以运行，为什么到了你的机器上就报错了？”这个问题通常是由于环境不一致导致的：操作系统、依赖库、配置文件等细微差别都可能让程序“水土不服”。\nDocker 就是为了解决这个问题而生的。\nDocker 是一个开源的容器化平台，它允许你将应用程序及其所有依赖项（代码、运行时、系统工具、系统库、设置）打包成一个标准化、轻量级、可移植的容器。这个容器可以在任何安装了 Docker 的机器上运行，保证环境完全一致。\nDocker 与虚拟机的区别\n\n\n特性\n虚拟机 (VM)\nDocker 容器\n\n\n\n抽象层级\n硬件级别\n操作系统级别\n\n\n隔离性\n完全隔离，更安全\n进程级别隔离，相对轻量\n\n\n启动速度\n慢 (分钟级)\n快 (秒级)\n\n\n性能\n有损耗，占用资源多\n接近原生，占用资源少\n\n\n磁盘占用\nGB 级别\nMB 级别\n\n\n本质\n一套完整的虚拟化系统\n一个隔离的进程\n\n\n简单来说，虚拟机是虚拟出一整套硬件，并在上面运行一个完整的操作系统。而 Docker 容器是直接在你的主机操作系统上隔离运行进程，共享主机内核，因此极其轻量和高效。\n二、核心概念要理解 Docker，必须掌握三个核心概念：镜像、容器、仓库。它们的关系可以用面向对象编程来类比：\n1. 镜像 (Image)\n类比： 面向对象中的 类 (Class)\n是什么： 一个只读的模板。它包含了创建 Docker 容器所需的所有文件和配置信息（如代码、运行时环境、库、环境变量、配置文件等）。镜像本身是静态的、不可改变的。\n例子： 一个 Ubuntu 镜像、一个安装了 Nginx 的镜像、一个包含了你的 Python 应用的镜像。\n\n2. 容器 (Container)\n类比： 面向对象中 类的实例 (Instance)\n是什么： 镜像的运行实例。当你运行一个镜像时，Docker 会在镜像的上方创建一个可写层，这个运行中的实体就是容器。容器可以被启动、开始、停止、删除。每个容器都是相互隔离的。\n例子： 你基于 Ubuntu 镜像运行了一个容器，就像你安装并启动了一个 Ubuntu 系统一样，可以在里面执行命令。\n\n3. 仓库 (Repository)\n类比： Git 仓库 或 应用商店\n是什么： 用来存放镜像的地方。Docker 官方提供了一个巨大的公共仓库 —— Docker Hub，就像 GitHub 一样，你可以在上面下载别人制作好的镜像，也可以上传自己的镜像。\n标签 (Tag)： 一个仓库里可以有多个镜像，通常用标签来区分不同版本（如 ubuntu:20.04, ubuntu:22.04）。\n\n三者关系总结：仓库 里存放着很多 镜像。你用 docker run 命令把 镜像 运行起来，就创建了一个 容器。\n三、安装 Docker在开始使用前，需要先安装 Docker：\n\nWindows&#x2F;Mac: 下载并安装 Docker Desktop\nUbuntu: sudo apt-get updatesudo apt-get install docker.iosudo systemctl start dockersudo systemctl enable docker\nCentOS:sudo yum install -y yum-utilssudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.reposudo yum install docker-ce docker-ce-cli containerd.iosudo systemctl start dockersudo systemctl enable docker\n\n安装完成后，运行 docker --version 验证安装是否成功。\n四、基本使用命令1. 生命周期管理\ndocker run [OPTIONS] IMAGE [COMMAND]\n\n核心命令！ 从镜像创建并启动一个容器。\n常用选项:\n-d: 后台运行容器（守护模式）\n-it: 交互模式运行容器（通常一起使用）\n--name: 为容器指定一个名字\n-p: 端口映射，格式 主机端口:容器端口\n-v: 数据卷映射，用于持久化数据\n-e: 设置环境变量\n\n\n例子:# 后台启动 Nginxdocker run -d --name mynginx -p 8080:80 nginx:latest# 交互式启动 Ubuntudocker run -it ubuntu:20.04 /bin/bash\n\n\ndocker start/stop/restart CONTAINER\n\n启动 &#x2F; 停止 &#x2F; 重启一个已存在的容器\n\ndocker rm CONTAINER\n\n删除一个已停止的容器\n-f: 强制删除（包括正在运行的容器）\ndocker rm -f $(docker ps -aq): 危险命令！ 强制删除所有容器\n\n\ndocker exec [OPTIONS] CONTAINER COMMAND\n\n在正在运行的容器中执行命令\n例子：docker exec -it mynginx /bin/bash  # 进入容器内部\n\n\n\n2. 镜像管理\ndocker pull IMAGE[:TAG]\n\n从仓库下载镜像到本地\ndocker pull ubuntu:20.04\n\n\ndocker images\n\n列出本地所有镜像\n\n\ndocker rmi IMAGE\n\n删除本地镜像\n\n\ndocker build [OPTIONS] PATH\n\n根据 Dockerfile 构建新镜像\n-t: 给镜像打标签\ndocker build -t my-app:1.0 .\n\n\n\n3. 信息查看\ndocker ps [OPTIONS]\n\n列出容器\n-a: 列出所有容器（包括已停止的）\n\n\ndocker logs CONTAINER\n\n查看容器日志\n-f: 实时跟踪日志\n\n\n\n五、Dockerfile 实战镜像是通过 Dockerfile 构建出来的。Dockerfile 是一个文本文件，包含了一系列指令，告诉 Docker 如何构建镜像。\n一个简单的 Dockerfile 示例# 使用官方 Python 运行时作为父镜像FROM python:3.9-slim# 设置工作目录WORKDIR /app# 复制当前目录内容到容器中COPY . /app# 安装依赖包RUN pip install --no-cache-dir -r requirements.txt# 暴露端口EXPOSE 80# 定义环境变量ENV NAME World# 容器启动时运行应用CMD [&quot;python&quot;, &quot;app.py&quot;]\n\n常用 Dockerfile 指令以下是最关键和最常用的指令：\n\n\n\n指令\n用途\n示例\n\n\n\nFROM\n指定基础镜像。所有 Dockerfile 都必须以 FROM 开头（ARG 除外）。\nFROM ubuntu:20.04\n\n\nRUN\n执行命令并创建新的镜像层。常用于安装软件包。\nRUN apt-get update &amp;&amp; apt-get install -y nginx\n\n\nCOPY\n从构建上下文复制文件或目录到镜像内的路径。\nCOPY ./app /usr/src/app\n\n\nADD\n类似 COPY，但功能更多（如自动解压 tar 包，从 URL 下载）。推荐优先使用 COPY。\nADD https://example.com/file.tar.gz /tmp/\n\n\nWORKDIR\n设置工作目录。相当于 cd，后续的 RUN, CMD, ENTRYPOINT, COPY, ADD 指令都会在此目录下执行。\nWORKDIR /app\n\n\nEXPOSE\n声明容器运行时监听的端口。这只是一个文档化的提示，实际映射端口需要在 docker run 时用 -p 参数指定。\nEXPOSE 80\n\n\nENV\n设置环境变量。这个变量在构建阶段和容器运行时都存在。\nENV NODE_ENV production\n\n\nARG\n定义构建时的变量，只在构建阶段有效，容器运行时不存在。\nARG APP_VERSION=1.0\n\n\nCMD\n指定容器启动时默认执行的命令。一个 Dockerfile 只能有一条 CMD 指令。如果被 docker run 后面的命令覆盖，则不会执行。\nCMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]\n\n\nENTRYPOINT\n配置容器启动时运行的命令，并且不会被 docker run 后面的命令覆盖，而是会将其后面的参数作为参数传递给 ENTRYPOINT 指令指定的程序。\nENTRYPOINT [&quot;echo&quot;]\n\n\nUSER\n指定运行容器时的用户名或 UID，后续的 RUN, CMD, ENTRYPOINT 都会以此身份运行。\nUSER nobody\n\n\nVOLUME\n创建一个匿名数据卷挂载点，用于存储动态数据。\nVOLUME /var/log\n\n\n使用 Dockerfile 的步骤关键步骤：\n\n选择合适的基础镜像\n设置工作目录\n复制文件并安装依赖\n暴露端口\n定义启动命令\n\n示例一：Node.js 项目假设有一个标准的 Node.js 项目，结构如下：\nmy-node-app/├── Dockerfile├── .dockerignore├── package.json├── package-lock.json (或 yarn.lock)└── src/    └── index.js (主文件)\n\n1. 编写 Dockerfile\n创建一个名为 Dockerfile 的文件，内容如下：\n# 使用官方 Node.js 运行时作为父镜像# 选择 Alpine 版本以极大减小镜像体积# node:18-alpine 不是一个裸的 Node.js 运行时，它是一个完整的、最小化的 Linux 操作系统（Alpine Linux），并且已经预装了 Node.js 18FROM node:18-alpine# 设置容器内的工作目录WORKDIR /usr/src/app# 如果需要的应用依赖需要额外的系统库，在这里安装# 例如，安装 Python3、g++、make 等用于编译原生模块# 使用 apk add --no-cache 来安装并避免缓存，保持镜像小巧RUN apk add --no-cache \\    python3 \\    g++ \\    make# 首先只复制包管理文件# 这步利用了 Docker 的缓存机制：只有当 package.json 变化时，才会重新执行 npm installCOPY package*.json ./# 安装项目依赖（使用 ci 命令用于持续集成，能根据 lockfile 精确安装）RUN npm ci --only=production# 这行命令会：# 1. 删除已有的 node_modules（如果有）# 2. 严格读取 package-lock.json# 3. 只安装 dependencies 部分的包（不安装 devDependencies）# 4. 最终得到一个与 lockfile 完全一致的、纯净的生产环境依赖目录# 如果也需要安装 devDependencies（如用于构建），请使用：# RUN npm ci# 去掉 `--only=production` 选项，那么 dependencies 和 devDependencies 里的所有包都会被安装。# 这通常只在需要编译源代码（例如用 TypeScript、Webpack 打包）的“构建阶段”才需要。# 将应用程序的其余源代码复制到工作目录COPY . .# 应用程序默认暴露的端口EXPOSE 3000# 定义运行时的环境变量（可选）# ENV NODE_ENV production# 启动应用程序# 假设 package.json 中有一个 &quot;start&quot; 脚本CMD [&quot;npm&quot;, &quot;start&quot;]\n\n2. 创建 .dockerignore 文件\n创建一个 .dockerignore 文件，防止不必要的文件被复制到镜像中，加速构建过程：\nnode_modulesnpm-debug.log.git.gitignoreREADME.md.envDockerfile.dockerignore\n\n3. 构建镜像\n在包含 Dockerfile 的目录下打开终端，执行构建命令：\n# -t 参数为镜像命名和打标签docker build -t my-node-app:1.0 .\n\n4. 运行容器\n从构建好的镜像启动一个容器：\n# -p 参数将本机的 49160 端口映射到容器的 3000 端口# -d 参数让容器在后台运行（ detached mode ）# --name my-running-node-app 方便后续管理。如果没有 --name，Docker 会随机分配一个名字，难以记忆和操作。docker run -d -p 49160:3000 --name my-running-node-app my-node-app:1.0\n\n现在，Node.js 应用就在容器中运行了，可以通过 http://localhost:49160 访问。\n5. 后续操作\n# 停止容器docker stop my-running-node-app# 启动已停止的容器docker start my-running-node-app# 查看容器日志docker logs my-running-node-app# 进入容器内部docker exec -it my-running-node-app sh\n\n\n\n示例二：Java (Spring Boot) 项目假设有一个标准的 Spring Boot 项目，使用 Maven 构建，项目结构如下：\nmy-java-app/├── Dockerfile├── .dockerignore├── pom.xml└── src/    └── main/        └── java/... (源代码)\n通常，会先使用 mvn package 打包得到一个 .jar 文件（如 target/my-app-1.0.0.jar）。\n1. 编写 Dockerfile (多阶段构建 - 推荐)\n多阶段构建可以产生一个非常小的、只包含运行时环境和 JAR 文件的最终镜像。\n# 第一阶段：构建阶段 (Builder)# 使用 Maven 镜像来编译和打包项目FROM maven:3.8.6-eclipse-temurin-17-alpine AS builderWORKDIR /app# 复制 pom.xml 和源代码COPY pom.xml .COPY src ./src# 打包项目，跳过测试RUN mvn package -DskipTests# 第二阶段：运行阶段# 使用一个更小的仅包含 JRE 的镜像来运行应用FROM eclipse-temurin:17-jre-alpineWORKDIR /app# 从构建阶段复制打包好的 jar 文件# 注意：这里的 jar 包名称需要和你的 pom.xml 中定义的最终名称匹配COPY --from=builder /app/target/*.jar app.jar# 暴露 Spring Boot 的默认端口EXPOSE 8080# 启动应用程序ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;app.jar&quot;]# 可以添加额外的 JVM 参数，例如：# ENTRYPOINT [&quot;java&quot;, &quot;-Xmx256m&quot;, &quot;-jar&quot;, &quot;app.jar&quot;]\n\n2. 创建 .dockerignore 文件\ntarget/.git.gitignoreREADME.md*.logDockerfile.dockerignore\n\n3. 构建镜像\n在包含 Dockerfile 和 pom.xml 的目录下执行：\ndocker build -t my-java-app:1.0 .\n\n4. 运行容器\n# 将本机的 8080 端口映射到容器的 8080 端口docker run -d -p 8080:8080 --name my-running-java-app my-java-app:1.0\n\n现在，你的 Spring Boot 应用就在容器中运行了，可以通过 http://localhost:8080 访问。\n六、典型工作流程\n编写应用代码：开发你的应用程序\n编写 Dockerfile：定义如何为应用构建镜像\n构建镜像：使用 docker build -t my-app . 命令\n运行容器：使用 docker run -d -p 4000:80 my-app 命令\n测试访问：在浏览器中打开应用验证\n上传分享：使用 docker push 将镜像上传到仓库\n\n七、学习资源官方文档\n\nDocker 官方文档 - 最权威的学习资源\nDocker Hub - 官方镜像仓库\n\n实践教程\n\nDocker 入门教程 - 交互式教程\nPlay with Docker - 在线 Docker 实验环境\n\n社区与博客\n\nDocker 官方博客\nDocker 中文社区\n\n","categories":["开发工具","运维部署"],"tags":["Docker","容器化","DevOps","云原生"]},{"title":"JavaScript异步编程：从回调到Promise","url":"/2023/08/03/Promise/","content":"什么是异步先来看下面这样一个关于时间规划的小学数学题：\n\n题目：四年级小敏每天起床后要做的事情有：穿衣（3分钟），整理床铺（2分钟），洗脸梳头（8分钟），上厕所（5分钟），烧饭（20分钟），吃早饭（12分钟），完成这些工作要50分钟。你认为最合理的安排是多少分钟？\n答案：6:00 起床├─ 6:00-6:03 穿衣（3分钟）├─ 6:03-6:05 整理床铺（2分钟）├─ 6:05-6:25 烧饭（20分钟）│   ├─ 6:05-6:13 洗脸梳头（8分钟） ← 和烧饭完全重叠│   ╰─ 6:13-6:18 上厕所（5分钟）   ← 也在烧饭期间完成╰─ 6:25-6:30 吃早饭（5分钟）\n\n题目很简单，我们也能很快的想到答案，烧饭是一件很耗时且不需要太多人工参与的事情，我们就可以利用这段时间去处理其他事情。但这和异步有什么关系呢？\n可以简单的说，像题目中这样：在同一时间段内，可以同时处理多件事情，不需要等前一个事情处理完成，才能处理下一个的场景，就是异步。在同一时间段内，只能处理一件事情，需要等待前一个事情处理完成后，才能开始处理下一个事情的场景，就是同步。\n在程序的世界里，也存在许多类似于烧饭的处理，例如：文件的I&#x2F;O处理、数据库操作等。在同步代码中，当一个任务（如读取文件、数据库查询）执行时，整个线程会被阻塞，无法处理其他请求，导致CPU空闲等待。这不仅会影响到用户的体验，还造成资源的浪费。\n而JavaScript 是单线程语言，同一时间只能执行一个任务，那该如何解决这个问题呢？\n怎么实现异步回调函数有人可能会想到，我们可以使用回调函数来实现异步。例如：\n// 代码中用毫秒代替分钟setTimeout(() =&gt; &#123;    console.log(&quot;6:05-6:13 洗脸梳头（8分钟）&quot;);        setTimeout(() =&gt; &#123;        console.log(&quot;6:13-6:18 上厕所（5分钟）&quot;);        // 烧饭完成后        setTimeout(() =&gt; &#123;            console.log(&quot;6:25 饭烧好了&quot;);        &#125;, 20 - 5 - 8); // 烧饭时间减去已经过去的时间            &#125;, 8); // 洗脸梳头8分钟    &#125;, 5); // 穿衣+整理床铺共5分钟/*输出：    6:05-6:13 洗脸梳头（8分钟）    6:13-6:18 上厕所（5分钟）    6:25 饭烧好了*/\n\n但如果使用回调函数来描述整个场景呢？\nconsole.log(&quot;6:00 起床&quot;);setTimeout(() =&gt; &#123;    console.log(&quot;6:00-6:03 穿衣（3分钟）&quot;);    setTimeout(() =&gt; &#123;        console.log(&quot;6:03-6:05 整理床铺（2分钟）&quot;);        console.log(&quot;6:05-6:25 开始烧饭（20分钟）&quot;);        // 在烧饭期间并行执行其他任务        setTimeout(() =&gt; &#123;            console.log(&quot;6:05-6:13 洗脸梳头（8分钟）&quot;);                            setTimeout(() =&gt; &#123;                console.log(&quot;6:13-6:18 上厕所（5分钟）&quot;);                                // 烧饭完成后                setTimeout(() =&gt; &#123;                    console.log(&quot;6:25 饭烧好了&quot;);                                        setTimeout(() =&gt; &#123;                        console.log(&quot;6:25-6:30 吃早饭（5分钟）&quot;);                        console.log(&quot;6:30 所有任务完成&quot;);                    &#125;, 5); // 5分钟吃早饭                &#125;, 20 - 13); // 烧饭总时间减去已经过去的时间            &#125;, 8); // 穿衣+整理床铺+洗脸梳头共13分钟        &#125;, 5); // 穿衣+整理床铺共5分钟    &#125;, 2); // 整理床铺2分钟&#125;, 3); // 穿衣3分钟/*输出：\t6:00 起床    6:00-6:03 穿衣（3分钟）    6:03-6:05 整理床铺（2分钟）    6:05-6:25 开始烧饭（20分钟）    6:05-6:13 洗脸梳头（8分钟）    6:13-6:18 上厕所（5分钟）    6:25 饭烧好了    6:25-6:30 吃早饭（5分钟）    6:30 所有任务完成*/\n\n可以看到，函数嵌套的过深，不仅影响了代码的可读性，还会难以调试和维护。在JavaScript异步编程中，这种多层嵌套回调函数形成的复杂代码结构被称为回调地狱（Callback Hell）。\n\n回调地狱（Callback Hell），也称为金字塔厄运（Pyramid of Doom），是指 JavaScript 中由于多层嵌套回调函数导致的代码结构复杂、难以维护的现象。\n带来的问题：\n​\t① 代码可读性差\n​\t② 错误处理复杂\n​\t③ 调试困难\n​\t……\n\n但在实际的开发中，我们不可避免的会遇到这种复杂的业务场景，该怎么解决回调地狱的问题呢？\nPromiseJavaScript中的一种异步编程模式，解决了回调地狱的问题，帮助开发者更清晰地处理异步操作，使代码更易读、易维护。\n核心原理与工作机制Promise 本质上是一个内置构造函数，用于创建 Promise 对象实例。每个 Promise 实例内部维护着两个关键属性：\n\nPromiseState（状态机）：\n\npending：初始状态，表示异步操作正在进行中\nfulfilled：操作成功完成（通过 resolve() 触发）\nrejected：操作失败或被拒绝（通过 reject() 或抛出异常触发）\n\n\nPromiseResult（结果容器）：\n\n存储异步操作的返回值（resolve 传入的值）\n或存储错误信息（reject 传入的错误对象）\n\n\n\n状态转换规则：\n\n创建时自动初始化为 pending 状态\n通过 resolve(value) 转换为 fulfilled，并存储结果值\n通过 reject(reason) 或抛出异常转换为 rejected，并存储错误信息\n状态转换是单向且不可逆的，一旦确定就不可更改\n\n执行流程：\n\n实例化 Promise 时，执行器函数（executor）立即执行\n通过 then() 方法注册回调：\n当状态变为 fulfilled，触发第一个回调函数\n当状态变为 rejected，触发第二个回调函数（或 catch()）\n\n\n通过 finally() 注册最终回调（无论成功失败都会执行）\n\n优点\n避免回调地狱\n链式调用\n错误处理更简单\n…..\n\n基本用法/*\t1. 创建一个 Promise 对象\t创建Promise时，构造函数接收一个执行器函数，在函数里写具体的处理逻辑，\t函数中有两个参数resolve/reject，这两个参数也是方法，在操作完成时调用。\t· resolve(value)：当异步操作成功时调用，存储成功信息。\t· reject(reason)：当异步操作失败时调用，存储错误信息。*/const myPromise = new Promise((resolve, reject) =&gt; &#123;\t// 异步操作......    if(condition) &#123;\t// 处理成功        resolve(&quot;成功！&quot;);\t// 调用 resolve    &#125; else &#123;\t// 处理失败        reject(&quot;失败！&quot;); // 调用 reject    &#125;&#125;);/*\t2. 使用 then/catch/finally 处理执行结果        then(result): Promise成功时执行            - 接收成功结果            - 可返回新值（成为新Promise的resolve值）            - 可链式调用        catch(error): Promise失败时执行\t            - 专门处理错误            - 可捕获前面所有then中的错误            - 也能返回新值        finally(): 无论成功失败都执行\t            - 不接收参数            - 通常放在最后，用于清理操作            - 不影响Promise链的最终值*/myPromise  .then((result) =&gt; &#123;    console.log(&quot;成功结果:&quot;, result);    return &quot;新的值&quot;; // 可传递给下一个then  &#125;)  .catch((error) =&gt; &#123;    console.error(&quot;失败原因:&quot;, error);    throw new Error(&quot;处理错误&quot;); // 可继续抛出错误  &#125;)  .finally(() =&gt; &#123;    console.log(&quot;无论成功失败都会执行&quot;);  &#125;);\n\n核心特点\n\n\n特性\n说明\n\n\n\n状态不可逆\npending → fulfilled（成功）或 rejected（失败）\n\n\n链式调用\n.then() 返回新的 Promise，可继续 .then()\n\n\n错误冒泡\n错误会一直传递到最近的 .catch()\n\n\n微任务队列\nPromise 回调属于微任务（比 setTimeout 宏任务优先级高）\n\n\n常用方法以下是 Promise 静态方法的对比汇总表格：\n\n\n\n方法\n描述\n成功条件\n失败条件\n返回值\n特点\n\n\n\nPromise.resolve()\n创建立即完成的Promise\n总是成功\n无\n传入的值\n快速包装值为Promise\n\n\nPromise.reject()\n创建立即拒绝的Promise\n无\n总是失败\n传入的错误\n快速创建拒绝的Promise\n\n\nPromise.all()\n处理多个Promise\n所有Promise成功\n任意一个失败\n结果数组（按输入顺序）\n一个失败立即拒绝，不等待其他\n\n\nPromise.allSettled()\n处理多个Promise\n所有Promise完成（无论成功失败）\n不会失败\n状态对象数组：&#123;status: &#39;fulfilled&#39;, value&#125;&#123;status: &#39;rejected&#39;, reason&#125;\n等待所有Promise最终状态\n\n\nPromise.race()\n处理多个Promise\n第一个完成的Promise（成功&#x2F;失败）\n第一个失败的Promise\n第一个完成的结果\n只关心最先完成的结果\n\n\nPromise.any()\n处理多个Promise\n任意一个Promise成功\n全部Promise失败\n第一个成功的结果\n忽略拒绝，只取第一个成功值\n\n\n示例代码：\n// Promise.allPromise.all([p1, p2]).then(results =&gt; &#123;  console.log(&#x27;所有成功:&#x27;, results); // [v1, v2]&#125;).catch(err =&gt; &#123;  console.log(&#x27;首个失败:&#x27;, err);&#125;);// Promise.allSettledPromise.allSettled([p1, p2]).then(results =&gt; &#123;  results.forEach(result =&gt; &#123;    if (result.status === &#x27;fulfilled&#x27;) &#123;      console.log(&#x27;成功:&#x27;, result.value);    &#125; else &#123;      console.log(&#x27;失败:&#x27;, result.reason);    &#125;  &#125;);&#125;);// Promise.racePromise.race([p1, p2]).then(winner =&gt; &#123;  console.log(&#x27;首个完成:&#x27;, winner);&#125;);// Promise.anyPromise.any([p1, p2]).then(firstSuccess =&gt; &#123;  console.log(&#x27;首个成功:&#x27;, firstSuccess);&#125;).catch(err =&gt; &#123;  console.log(&#x27;全部失败:&#x27;, err.errors); // AggregateError&#125;);\n\n使用场景建议：\n\n全成功才继续：用 Promise.all\n收集所有结果：用 Promise.allSettled\n竞速响应：用 Promise.race\n任一成功即可：用 Promise.any\n\n重构时间规划问题// 创建一个延迟执行的 Promise 辅助函数function delay(taskName, minutes) &#123;  return new Promise(resolve =&gt; &#123;    setTimeout(() =&gt; &#123;      console.log(`$&#123;taskName&#125;（$&#123;minutes&#125;分钟）`);      resolve();    &#125;, minutes); // 用毫秒代替分钟，便于演示  &#125;);&#125;// 主流程开始console.log(&quot;6:00 起床&quot;);// 穿衣delay(&quot;6:00-6:03 穿衣&quot;, 3)  .then(() =&gt; &#123;    // 整理床铺    return delay(&quot;6:03-6:05 整理床铺&quot;, 2);  &#125;)  .then(() =&gt; &#123;    console.log(&quot;6:05-6:25 开始烧饭（20分钟）&quot;);        // 烧饭主任务    const cooking = delay(&quot;6:25 饭烧好了&quot;, 20);        // 并行任务1: 洗脸梳头    const faceWashing = delay(&quot;6:05-6:13 洗脸梳头&quot;, 8);        // 并行任务2: 上厕所（在洗脸梳头之后）    const toilet = faceWashing.then(() =&gt; delay(&quot;6:13-6:18 上厕所&quot;, 5));        // 等待所有并行任务完成    return Promise.all([cooking, toilet]);  &#125;)  .then(() =&gt; &#123;    // 吃早饭    return delay(&quot;6:25-6:30 吃早饭&quot;, 5);  &#125;)  .then(() =&gt; &#123;    console.log(&quot;6:30 所有任务完成&quot;);  &#125;)  .catch(error =&gt; &#123;    console.error(&quot;流程出错:&quot;, error);  &#125;);\n\n虽然通过链式调用可以解决回调地狱的问题，但是我们还是可以看到then()中嵌套then()的现象，代码的可读性还是不够好。\nasync&#x2F;await是什么？async&#x2F;await 是 ES2017 引入的语法糖，基于 Promise 的异步编程解决方案，让异步代码拥有同步代码的书写方式。\n核心本质：\n\nasync：将函数标记为异步，总是返回 Promise 对象\nawait：暂停异步函数执行，等待 Promise 解决\n\n用法通过async可以来创建一个异步函数，async函数会返回一个Promise对象。\n1. 声明异步函数async function fetchData() &#123;  return &#x27;data&#x27;; // 自动包装为 resolved Promise&#125;// 等价于function fetchData() &#123;  return Promise.resolve(&#x27;data&#x27;);&#125;\n\n2. 等待异步结果async function getUser() &#123;  const response = await fetch(&#x27;/api/user&#x27;); // 等待Promise解决  const data = await response.json(); // 再次等待  return data;&#125;\n\n注意事项1.使用范围await只能在async函数中使用，或ES模块的顶层作用域中使用。await阻塞的只是异步函数内部的代码，不会影响外部代码。\n\nES模块的顶层作用域是什么？\nES模块的顶层作用域指的是在模块的最外层，不在任何函数或类内部的代码块。这种情况下，顶层作用域的代码会在模块加载时立即执行。\n\nhtml中：\n\n&lt;script type=&quot;module&quot;&gt;    await Promise.resolve().then(() =&gt; console.log(&quot;Hello&quot;));&lt;/script&gt;\n2. 错误处理通过await调用异步代码时，需要通过try…catch来捕获异常\n// 方式1：try/catchasync function fetchWithTryCatch() &#123;  try &#123;    const data = await fetchData();  &#125; catch (err) &#123;    console.error(&#x27;捕获错误:&#x27;, err);  &#125;&#125;// 方式2：catch回调async function fetchWithCatch() &#123;  const data = await fetchData().catch(err =&gt; &#123;    console.error(&#x27;捕获错误:&#x27;, err);  &#125;);&#125;\n\n3. 并行优化// 错误：顺序执行（耗时较长）async function sequential() &#123;  const a = await fetchA(); // 等待完成  const b = await fetchB(); // 才开始&#125;// 正确：并行执行async function parallel() &#123;  const [a, b] = await Promise.all([fetchA(), fetchB()]);&#125;\n\n常见陷阱\n忘记await：导致后续代码使用未resolved的Promise\nasync function demo() &#123;  const data = fetchData(); // 缺少await！  console.log(data); // 输出: Promise &#123;&lt;pending&gt;&#125;&#125;\n\n不必要await：同步操作无需await\nasync function unnecessary() &#123;  await console.log(&#x27;这不需要await&#x27;); // 反模式&#125;\n\n循环中使用：可能需要重构为for…of顺序执行\nasync function processArray(array) &#123;  for (const item of array) &#123; // 替代forEach/map    await processItem(item);  &#125;&#125;\n\n重构时间规划问题// 辅助函数：模拟延迟执行并记录时间async function delay(taskName, minutes) &#123;    return new Promise(resolve =&gt; &#123;        setTimeout(() =&gt; &#123;            console.log(`$&#123;taskName&#125;（$&#123;minutes&#125;分钟）`);            resolve();        &#125;, minutes); // 用毫秒代替分钟，便于演示    &#125;);&#125;// 主流程async function morningRoutine() &#123;    console.log(`6:00 起床`);    // 顺序执行穿衣和整理床铺    await delay(&quot;6:00-6:03 穿衣&quot;, 3);    await delay(&quot;6:03-6:05 整理床铺&quot;, 2);    // 开始烧饭并并行执行其他任务    console.log(`6:05 开始烧饭（20分钟）`);    // 并行执行的任务    const tasks = [        // 洗脸梳头（8分钟）和上厕所（5分钟）的链式调用        (async () =&gt; &#123;            // 洗脸梳头（8分钟）            await delay(&quot;6:05-6:13 洗脸梳头&quot;, 8);// 上厕所（5分钟）            return await delay(&quot;6:13-6:18 上厕所&quot;, 5);        &#125;)(),        // 烧饭任务（20分钟）        delay(&quot;6:25 饭烧好了&quot;, 20)    ];    await Promise.all(tasks);    // 吃早饭    await delay(&quot;6:25-6:30 吃早饭&quot;, 5);    console.log(&quot;6:30 所有任务完成&quot;);&#125;// 执行流程morningRoutine().catch(err =&gt; console.error(&quot;流程出错:&quot;, err));\n\nJS是单线程的，那么它是如何实现异步处理的呢？\n在深入探讨解决方案之前，让我们先理解一个概念：事件循环（Event Loop）。JavaScript 通过事件循环（Event Loop）机制，在保持单线程执行模型的同时，实现了异步操作的高效处理。下面我们将详细解析这一重要机制。\n原理：事件循环（Event Loop）事件循环是JavaScript中的一个的运行时模型，负责程序执行期间的资源管理、任务处理和协调操作，它定义了代码如何被调度和执行的。\n关键组件\n\n\n组件\n说明\n常见例子\n\n\n\n调用栈（Call Stack）\n同步代码的执行栈，遵循后进先出（LIFO）。若栈溢出（如无限递归）会报错。\n同步代码（如 console.log）、函数调用\n\n\n任务队列（Task Queue）\n即宏任务队列，是事件循环中处理”常规”异步任务的队列。\nsetTimeout、setInterval、DOM事件、I&#x2F;O（如 fs.readFile）\n\n\n微任务队列（Microtask Queue）\n存放微任务，每轮事件循环结束后立即清空，优先级高于宏任务。\nPromise.then、MutationObserver、queueMicrotask、process.nextTick。\n\n\n事件循环(Event Loop)关键组件示意图\nflowchart TD\n    subgraph 队列\n        direction LR\n        subgraph 任务队列_宏任务队列[\"任务队列（宏任务队列）\"]\n            H[setTimeout]\n            I[setInterval]\n            J[DOM事件]\n            K[I/O回调]\n        end\n        \n        subgraph 微任务队列[\"微任务队列\"]\n            E[Promise.then]\n            F[queueMicrotask]\n            G[MutationObserver]\n        end\n    end\n    \n    subgraph 调用栈[\"调用栈\"]\n        A[全局执行上下文] --> B[函数1]\n        B --> C[函数2]\n        C --> D[console.log]\n    end\n执行流程简化的执行顺序：1. 同步代码 → 2. 微任务 → 3. 宏任务\n\n调用栈检查阶段\n事件循环首先检查调用栈(Call Stack)状态\n若调用栈不为空，则继续执行栈中的同步代码\n若调用栈为空，则进入任务队列处理阶段\n\n\n微任务处理阶段\n当调用栈清空后，事件循环会优先处理微任务队列(Microtask Queue)\n依次执行微任务队列中的所有任务，直到队列完全清空\n\n\n宏任务处理阶段\n在微任务队列清空后，从宏任务队列(Macrotask Queue)中取出一个任务执行\n执行完毕后立即返回微任务检查阶段\n\n\n\n上述过程形成持续的事件循环(Event Loop)，每次宏任务执行后都会重新检查微任务队列，这种机制保证了高优先级任务的及时处理。\nflowchart TD\n    Start([开始]) --> Sync[执行同步代码]\n    Sync --> Micro{微任务队列空?}\n    Micro -->|否| ExecuteMicro[执行微任务] --> Micro\n    Micro -->|是| Macro{宏任务队列空?}\n    Macro -->|否| ExecuteMacro[执行宏任务] --> Sync\n    Macro -->|是| End([结束])","categories":["JavaScript","异步编程"],"tags":["异步编程","回调","Promise"]},{"title":"深入理解 Docker 数据卷：数据持久化的终极指南","url":"/2025/08/23/docker-volume/","content":"Docker 数据卷详解引言：为什么需要数据卷？在 Docker 的日常使用中，我们经常会遇到一个棘手的问题：“容器删除后，我的数据去哪儿了？” 想象一下这样的场景：您运行了一个 MySQL 容器，存储了重要业务数据，然后因为版本升级或配置变更删除了容器，结果发现所有数据都随之消失了。这种经历足以让任何开发者心惊胆战。\n正是为了解决这个痛点，Docker 数据卷（Volume）应运而生。数据卷不仅是 Docker 的核心功能，更是实现生产环境可靠部署的关键技术。\n一、数据卷是什么？核心定义数据卷是一个由 Docker 管理的、独立于容器生命周期的特殊目录。 它存在于宿主机上，但可以被一个或多个容器挂载和使用。\n可以通过一个比喻来理解数据卷：\n\n容器 → 一台电脑（或一台电脑上的一个用户账户）\n电脑可能会中毒、系统可能会崩溃，你可能会重装系统甚至换一台新电脑。\n\n\n镜像 → 电脑出厂时的预装系统（或系统安装盘）\n用它可以把任何一台电脑恢复到一模一样的状态。\n\n\n数据卷 → 外接的移动硬盘或U盘\n你的重要个人文件——工作文档、家庭照片、音乐库——从来都不只放在电脑的C盘里，而是习惯性地保存在移动硬盘上。\n这样，无论电脑本身发生什么变化，只要你的移动硬盘还在，数据就是安全的。你可以把这块硬盘插到任何一台新电脑上继续工作。\n\n\n\n这个比喻的核心是：数据卷是一个可移植、可插拔的独立存储设备。\n二、数据卷的核心特性1. 持久化（Persistence）数据卷的生命周期完全独立于容器。即使所有挂载它的容器都被删除，数据卷及其包含的数据仍然存在。\n2. 解耦（Decoupling）将应用程序数据与运行环境分离：\n\n容器：包含应用代码和运行环境\n数据卷：存储应用产生的数据、配置文件和日志\n\n3. 高性能Docker 管理的数据卷在大多数平台上都提供接近原生文件系统的性能表现。\n4. 易于管理支持方便的备份、恢复和迁移操作，与标准 Linux 工具完美兼容。\n5. 共享能力一个数据卷可以被多个容器同时挂载，实现容器间的数据共享和协作。\n三、数据卷的两种主要类型1. Docker 管理的数据卷（Named Volumes）🏆 推荐用于生产环境\n特点：\n\n由 Docker 完全管理\n存储在 Docker 的特定区域（通常是 /var/lib/docker/volumes/）\n通过友好名称引用，无需关心具体路径\n\n管理命令：\n# 创建数据卷docker volume create my-app-data# 查看所有数据卷docker volume ls# 查看数据卷详情docker volume inspect my-app-data# 删除未使用数据卷docker volume prune\n\n使用示例：\n# 运行 MySQL 并使用数据卷持久化数据docker run -d \\  --name mysql-db \\  -v mysql-data:/var/lib/mysql \\  -e MYSQL_ROOT_PASSWORD=secret \\  mysql:8.0  # 丢弃容器后docker stop mysql-dbdocker rm mysql-db# 重新部署：创建新容器，恢复旧数据docker run -d \\  --name new-mysql-db \\  -v mysql-data:/var/lib/mysql \\  -e MYSQL_ROOT_PASSWORD=secret \\  mysql:8.0\n\n参数解析：-v mysql-data:/var/lib/mysql\n\n-v: --volume 的简写。用于创建或使用一个数据卷，实现数据持久化。\nmysql-data: 这是数据卷的名称。Docker 会在宿主机上管理这个命名的存储空间。如果名为 mysql-data 的卷不存在，Docker 会自动创建它。\n/var/lib/mysql: 这是 MySQL 容器内部的路径。MySQL 官方镜像默认将其所有数据（数据库、表、用户信息等）都存储在这个目录下。\n映射关系：-v host-volume:container-path\n这里使用的是命名卷（Named Volume），所以 Docker 管理卷的具体存储位置（通常在 /var/lib/docker/volumes/ 下）。\n效果：任何写入容器内 /var/lib/mysql 的数据，实际上都被安全地写到了宿主机的 mysql-data 卷中。\n\n\n\n2. 绑定挂载（Bind Mounts）🔧 适合开发环境\n特点：\n\n将宿主机任意目录挂载到容器\n直接映射到指定路径\n用于开发时代码实时同步\n\n使用示例：\n# 开发时挂载源代码目录docker run -d \\  --name dev-server \\  -v /path/to/your/code:/app \\  -p 3000:3000 \\  node:18\n\n\n\n四、实战应用场景场景 1：数据库数据持久化# 创建专门的数据卷docker volume create postgres-data# 运行 PostgreSQL 容器docker run -d \\  --name postgres-db \\  -v postgres-data:/var/lib/postgresql/data \\  -e POSTGRES_PASSWORD=mysecretpassword \\  postgres:13# 安全升级：删除旧容器，用新镜像启动并重用数据卷docker stop postgres-dbdocker rm postgres-dbdocker run -d \\  --name postgres-new \\  -v postgres-data:/var/lib/postgresql/data \\  postgres:14 # 版本升级，数据保留！\n\n\n\n场景 2：多容器数据共享# 创建一个共享数据卷docker volume create shared-data# 容器A：写入数据docker run -d \\  --name producer \\  -v shared-data:/shared \\  alpine sh -c &quot;echo &#x27;Hello from Container A&#x27; &gt; /shared/message.txt&quot;# 容器B：读取数据docker run --rm \\  --name consumer \\  -v shared-data:/shared \\  alpine cat /shared/message.txt\n\n\n\n场景 3：开发环境实时同步# 绑定挂载源代码，实现实时重载docker run -d \\  --name dev-container \\  -v $(pwd)/src:/app/src \\  -v $(pwd)/public:/app/public \\  -p 3000:3000 \\  react-app\n\n\n\n五、高级技巧与最佳实践1. 使用 --mount 语法（更现代）# --mount 语法更明确，推荐在新项目中使用docker run -d \\  --mount source=my-volume,target=/app/data \\  --name my-app \\  my-app-image\n\n2. 设置数据卷权限# 确保容器用户有数据卷写入权限docker run -d \\  -v app-data:/app/data \\  -u 1000:1000 \\ # 指定用户UID和GID  my-app-image\n\n3. 数据备份与恢复这两个命令是 Docker 数据卷备份和恢复的“标准操作”，核心思想是创建一个“临时工具人”容器。\n这两个命令都没有启动一个长期运行的服务，而是启动一个极简的 Alpine Linux 容器，执行一个特定的任务（打包或解压），任务完成就自动退出并删除容器。\n--rm 选项就是这个思想的关键：它表示容器在运行结束后自动删除自己，不留任何痕迹，只留下我们想要的结果（备份文件或恢复的数据）。\n命令一：备份详解\ndocker run --rm \\           # ① 创建临时容器，任务完成即删  -v app-data:/source \\     # ② 把要备份的数据卷挂载到容器的 /source  -v $(pwd):/backup \\       # ③ 把当前目录挂载到容器的 /backup  alpine \\                  # ④ 使用 alpine 镜像  tar -czf /backup/app-data-backup.tar.gz -C /source .  # ⑤ 在容器内执行的备份命令\n\n步骤拆解：\n\n准备环境：Docker 拉取 alpine 镜像，并创建一个临时容器。\n挂载数据：\n-v app-data:/source：将名为 app-data 的数据卷挂载到容器内的 /source 目录。现在容器能看到 app-data 卷里的所有文件，它们就在 /source 下。\n-v $(pwd):/backup：将你当前的主机目录（例如 /home/user/backups）挂载到容器内的 /backup 目录。\n\n\n执行任务：容器启动后，不运行默认的 Shell，而是直接执行 tar 命令：\ntar -czf /backup/app-data-backup.tar.gz -C /source .\n相当于在容器里执行了 cd /source &amp;&amp; tar -czf /backup/app-data-backup.tar.gz .。\n\n\n清理：tar 命令执行完毕，容器任务完成，自动退出。--rm 选项触发，这个临时容器被销毁。但它通过挂载的卷，已经成功地把数据卷里的内容“搬运”到了你的主机上，形成了一个备份文件。\n\n比喻：这就像你雇了一个临时工（Alpine 容器），给了他两把钥匙：一把是仓库（app-data 卷）的钥匙，另一把是你家抽屉（当前目录）的钥匙。他的任务就是去仓库把所有的货物打包成一个箱子（tar.gz 文件），然后把这个箱子放进你的抽屉里。任务完成后，临时工就离开了。\n命令二：恢复详解\ndocker run --rm \\                 # ① 创建临时容器，任务完成即删  -v app-data:/target \\           # ② 把要恢复的目标数据卷挂载到容器的 /target  -v $(pwd):/backup \\             # ③ 把存有备份文件的主机目录挂载到容器的 /backup  alpine sh -c &quot;rm -rf /target/* &amp;&amp; tar -xzf /backup/app-data-backup.tar.gz -C /target&quot; # ④\n\n步骤拆解：\n\n准备环境：同上，创建临时 Alpine 容器。\n挂载数据：\n-v app-data:/target：将空白的（或有旧数据的）app-data 卷挂载到容器的 /target 目录。这是我们想要恢复数据的目标位置。\n-v $(pwd):/backup：将存有备份文件 app-data-backup.tar.gz 的主机目录挂载到容器的 /backup。\n\n\n执行任务：容器启动后，执行一个由 sh -c 连接的两个命令：\nrm -rf /target/\\*：清空目标卷。这是一个非常危险但必要的操作，它先删除 /target 下的所有内容，确保我们是从一个干净的状态恢复，避免新旧文件混杂冲突。\ntar -xzf /backup/app-data-backup.tar.gz -C /target：将备份包中的所有文件，解压到 /target 目录下，也就是解压到了 app-data 数据卷中。\n\n\n清理：任务完成，容器自动销毁。\n\n比喻：还是那个临时工，这次你给他的任务是：先去仓库（app-data 卷）把里面的旧东西全清空（rm -rf），然后把你抽屉里的那个备份箱子搬过来，打开，把里面的货物原封不动地摆回仓库里。摆完后他就离开。\n4. 数据卷清理策略定期清理无用数据卷，避免磁盘空间浪费：\n# 删除所有未使用的数据卷docker volume prune# 删除指定数据卷docker volume rm old-volume-name\n\n\n\n六、常见问题解答（FAQ）Q1: 数据卷存储在宿主机什么位置？A: Docker 管理的数据卷默认存储在 /var/lib/docker/volumes/ 目录下。每个数据卷都有自己独立的子目录。\nQ2: 如何查看数据卷的实际大小？A: 使用 docker system df -v 命令可以查看详细的空间使用情况，包括数据卷的大小。\nQ3: 数据卷能否跨主机共享？A: 原生的 Docker 数据卷不能直接跨主机共享。需要实现跨主机数据卷，可以考虑使用：\n\nNFS 等网络文件系统\nDocker 的卷插件（如 REX-Ray）\n分布式存储系统（如 Ceph, GlusterFS）\n\nQ4: 数据卷和绑定挂载哪个性能更好？A: 在大多数情况下，Docker 管理的数据卷性能更优，特别是在 macOS 和 Windows 的 Docker Desktop 环境中，因为数据卷在这些平台上有特殊的优化。\n七、其他学习资源\nDocker 官方文档 - 使用数据卷\nDocker Volume 插件列表\nAwesome Docker - 存储相关工具\n\n","categories":["容器技术","DevOps"],"tags":["Docker","数据卷","容器持久化","数据管理"]},{"title":"Node.js 开发必备：npm 与 package.json 常用命令与配置","url":"/2022/10/16/npm/","content":"npm 常用命令npm 基础配置镜像源管理# 设置淘宝镜像源npm set registry https://registry.npmmirror.com# 恢复官方源npm set registry https://registry.npmjs.org# 查看当前源npm config get registry\n\n代理配置# 设置代理npm config set proxy http://proxy.company.com:8080npm config set https-proxy http://proxy.company.com:8080# 删除代理npm config delete proxynpm config delete https-proxy\n\n全局配置# 查看所有配置npm config list# 设置全局安装路径npm config set prefix &quot;~/global_node_modules&quot;# 设置缓存路径npm config set cache &quot;~/npm_cache&quot;\n\n\n\n项目初始化与依赖管理初始化项目\nnpm init：创建 package.json 文件\n\n该命令会根据交互式提示，生成一个基本的 package.json 文件。\n\nnpm init\n\nnpm init -y：快速生成 package.json 文件\n\n这个命令会自动接受所有默认配置，并快速生成 package.json 文件，省去交互式输入。\n\nnpm init -y\n\n安装依赖\nnpm install &lt;package-name&gt; --save：安装生产依赖\n\n默认会安装最新版本的包，并将其记录在 package.json 的 dependencies 字段下。\n\n  npm install lodash --save# 或简写为  npm install lodash\n\nnpm install &lt;package-name&gt;@&lt;version&gt;：安装指定版本的依赖\nnpm install lodash@4.17.15\n\nnpm install &lt;package-name&gt; --save-dev：安装开发依赖\nnpm install eslint --save-dev\n\nnpm install -g &lt;package-name&gt;：安装全局工具\nnpm install -g typescriptnpm install -g typescript\n\nnpm install：安装项目中 package.json 中列出的所有依赖\nnpm install# 或简写为npm i\n\n卸载依赖\nnpm uninstall &lt;package-name&gt;：卸载指定的包\nnpm uninstall lodash\n\nnpm uninstall &lt;package-name&gt; --save-dev：从 devDependencies 中卸载依赖\nnpm uninstall jest --save-dev\n\n更新依赖\nnpm update：更新所有依赖包到符合 package.json 中指定的版本范围\nnpm update\n\nnpm update &lt;package-name&gt;：更新指定包\nnpm update lodash\n\n查看包信息\nnpm list：列出当前项目中所有安装的依赖\nnpm list\n\nnpm list &lt;package-name&gt;：查看指定包及其依赖的版本\nnpm list lodash\n\nnpm outdated：查看项目中哪些包有新版本可用\nnpm outdated\n\nnpm audit：检查安全漏洞\nnpm audit\n\n进阶技巧依赖锁定文件# 生成 package-lock.json（自动）npm install# 强制重新生成npm install --package-lock-only\n\n依赖检查# 查看项目依赖树npm list# 查看全局安装的包npm list -g --depth=0# 检查包信息npm view react\n\n发布包# 登录npm账号npm login# 发布包npm publish# 撤销发布（24小时内）npm unpublish &lt;package-name&gt;@&lt;version&gt;\n\n\n\nYarn 常用命令# 初始化项目（类似npm init）yarn init# 添加依赖yarn add lodashyarn add eslint --dev# 升级依赖yarn upgrade lodash# 删除依赖yarn remove lodash# 安装所有依赖yarn install# 或简写为yarn\n\n\n\npackage.json 常见配置项目元信息\nname：项目名称\nversion：项目版本\ndescription：项目描述\nmain：项目的入口文件（如 index.js）\n\n&#123;  &quot;name&quot;: &quot;my-project&quot;,  &quot;version&quot;: &quot;1.0.0&quot;,  &quot;description&quot;: &quot;A sample project&quot;,  &quot;main&quot;: &quot;index.js&quot;&#125;\n\n\n\n依赖配置\ndependencies：生产环境依赖项，项目运行时所需的包\ndevDependencies：开发环境依赖项，项目开发时所需的包\n\n&#123;  &quot;dependencies&quot;: &#123;    &quot;express&quot;: &quot;^4.17.1&quot;,    &quot;lodash&quot;: &quot;^4.17.20&quot;  &#125;,  &quot;devDependencies&quot;: &#123;    &quot;jest&quot;: &quot;^26.6.0&quot;  &#125;&#125;\n\n版本控制符号\n\n\n\n符号\n示例\n说明\n\n\n\n^\n^1.2.3\n允许更新次版本和修订号（1.x.x）\n\n\n~\n~1.2.3\n只允许更新修订号（1.2.x）\n\n\n&gt;\n&gt;1.2.3\n大于指定版本\n\n\n=\n=1.2.3\n精确版本\n\n\n-\n1.2.3 - 2.3.4\n版本范围\n\n\n脚本配置package.json 中的 scripts 字段定义了常用的命令脚本，使用 npm run &lt;script-name&gt; 来执行这些脚本。\n\nstart：通常用于启动项目\ntest：用于运行测试\nbuild：用于构建项目\n\n&#123;  &quot;scripts&quot;: &#123;    &quot;start&quot;: &quot;node server.js&quot;,    &quot;test&quot;: &quot;jest&quot;,    &quot;build&quot;: &quot;webpack --config webpack.config.js&quot;  &#125;&#125;\n\n执行脚本：\nnpm run startnpm run test\n\n 脚本进阶用法\n&#123;  &quot;scripts&quot;: &#123;    &quot;prebuild&quot;: &quot;echo &#x27;准备构建...&#x27;&quot;,  // 前置钩子    &quot;build&quot;: &quot;webpack&quot;,    &quot;postbuild&quot;: &quot;echo &#x27;构建完成！&#x27;&quot;, // 后置钩子        // 并行执行    &quot;dev&quot;: &quot;npm run server &amp; npm run watch&quot;,        // 串行执行    &quot;deploy&quot;: &quot;npm run build &amp;&amp; npm run publish&quot;  &#125;&#125;\n\n\n\n项目配置\nengines：指定 Node.js 或 npm 的版本要求\nlicense：项目的许可证\n\n&#123;  &quot;engines&quot;: &#123;    &quot;node&quot;: &quot;&gt;=14.0.0&quot;,    &quot;npm&quot;: &quot;^7.0.0&quot;  &#125;,  &quot;license&quot;: &quot;MIT&quot;&#125;\n\n\n\n环境变量配置\nscripts 中使用环境变量：在 scripts 部分中使用环境变量来区分不同的环境，如开发环境、生产环境等。\n\n&#123;  &quot;scripts&quot;: &#123;    &quot;start&quot;: &quot;NODE_ENV=production node app.js&quot;,    &quot;dev&quot;: &quot;NODE_ENV=development nodemon app.js&quot;  &#125;&#125;\n\n\n\n浏览器兼容性配置&#123;  &quot;browserslist&quot;: [      // 浏览器兼容性配置    &quot;&gt; 1%&quot;,    &quot;last 2 versions&quot;  ]&#125;\n\n\n\nnpm 配置文件除了 package.json 外，npm 还使用 .npmrc 配置文件来管理 npm 的配置选项。\n常见配置：\n\nregistry：设置 npm 的镜像源\n默认是 https://registry.npmjs.org/\n可以设置为国内镜像源，如 https://registry.npm.taobao.org/\n\n\n\nregistry=https://registry.npm.taobao.org/\n\n\nprefix：指定全局安装包的位置\n\nprefix=/usr/local/npm\n\n\n\n参考\nnpm 官方文档\nnpm package.json 文档\n语义化版本控制规范\nNode.js最佳实践\n\n","categories":["Node.js","npm"],"tags":["npm","package.json","包管理器"]},{"title":"Node.js 模块化详解：从 CommonJS 到 ES Modules","url":"/2022/10/12/nodejs-modules/","content":"1. 模块化概述1.1 什么是模块化模块化是将代码分割成独立的模块，每个模块负责特定的功能或逻辑。这种编程范式将大型程序分解为相互依赖的小文件，提高了代码的可维护性、可重用性和可测试性。\n模块化的核心优势：\n\n可维护性：每个模块独立存在，修改一个模块不会影响其他模块\n可重用性：模块可以在不同项目中复用，减少重复代码\n可测试性：模块可以单独测试，确保功能正确性\n命名空间管理：避免全局变量污染，减少命名冲突\n\n1.2 模块化的历史背景JavaScript 在浏览器端的模块化方式经历了从全局作用域到基于 script 标签的引用再到现代化的模块系统（如 ES6 模块）。然而，Node.js 的模块化是基于 CommonJS 规范开发的，这使得 Node.js 在服务器端也能够非常方便地实现模块化。\n1.3 模块化解决的问题\n命名冲突：传统JS开发中全局变量容易冲突，模块化提供了独立作用域\n文件依赖：明确模块间的依赖关系，避免手动管理script标签顺序\n代码组织：使项目结构更清晰，便于团队协作开发\n\n2. CommonJS 模块规范2.1 基本概念CommonJS是Node.js默认采用的模块化规范，主要特点包括：\n\n同步加载模块\n适用于服务端环境\n使用require()导入，module.exports或exports导出\n\n2.2 基本用法模块导入\n// 导入自定义模块（需以./或../开头）const m1 = require(&#x27;./m1&#x27;) // 扩展名可省略// 导入核心模块（直接写模块名）const path = require(&#x27;path&#x27;)const fs = require(&#x27;node:fs&#x27;) // node:前缀可提高查找效率\n\n文件查找规则：\n\n完整文件名：直接加载\n省略扩展名：按.js → .json → .node顺序尝试\n目录作为模块：查找目录下的index.js\n\n模块导出\nconst add = (a, b) =&gt; a + b;const multiply = (a, b) =&gt; a * b;// 方式1：逐个导出exports.number = 1exports.method = function() &#123;&#125;exports.add = add; exports.multiply = multiply;// 方式2：整体导出module.exports = &#123;  name: &#x27;zs&#x27;,  age: 25,  add,   multiply&#125;\n\n注意：exports只是module.exports的引用，不能直接赋值：\nexports = &#123;a: 1&#125; // 错误！不会生效\n\n\n\n2.3 模块加载原理Node.js 在加载一个 CommonJS 模块（如 require(‘.&#x2F;module.js’)）时，会将该模块的代码包裹在一个函数里，并传入 5 个关键参数：\n\nexports：用于导出模块内容（等同于 module.exports 的引用）。\nrequire：用于引入其他模块的函数。\nmodule：当前模块的元信息（如 module.exports）。\n__filename：当前模块文件的绝对路径。\n__dirname：当前模块所在目录的绝对路径。\n\n示例代码假设有一个模块文件 math.js：\n// math.jsconsole.log(arguments); // 查看包装函数的参数const add = (a, b) =&gt; a + b;module.exports = add; // 导出 add 函数\n当你在另一个文件 app.js 中引入它：\n// app.jsconst add = require(&#x27;./math.js&#x27;);console.log(add(2, 3)); // 输出 5\n运行 app.js 时，math.js 会被包装成：\n(function(exports, require, module, __filename, __dirname) &#123;  console.log(arguments); // 输出包装函数的参数  const add = (a, b) =&gt; a + b;  module.exports = add;&#125;)(...); // Node.js 会自动传入 5 个参数\n可以通过console.log(arguments)查看这些参数。输出示例：\n&#123;  &#x27;0&#x27;: &#123;&#125;,               // exports（初始为空对象）  &#x27;1&#x27;: [Function: require], // require 函数  &#x27;2&#x27;: Module &#123; ... &#125;,   // module 对象  &#x27;3&#x27;: &#x27;/path/to/math.js&#x27;, // __filename  &#x27;4&#x27;: &#x27;/path/to&#x27;         // __dirname&#125;\n\n\n\n2.4 文件夹作为模块当 require 的是一个目录时，Node.js 会按顺序查找：\n\npackage.json 的 main 字段：指定入口文件。\nindex.js：如果 package.json 不存在或未指定 main。\n\n示例 1：目录包含 package.json假设目录结构如下：\nhello/  ├── package.json  ├── a.js  └── b.js\npackage.json 内容：\n&#123;  &quot;main&quot;: &quot;a.js&quot;&#125;\n当你 require(‘.&#x2F;hello’) 时，实际加载的是 hello&#x2F;a.js。\n示例 2：目录不包含 package.json目录结构：\nhello/  ├── index.js  ├── a.js  └── b.js\n当你 require(‘.&#x2F;hello’) 时，默认加载 hello&#x2F;index.js。\n示例 3：既无 package.json 也无 index.js会报错：\nError: Cannot find module &#x27;./hello&#x27;\n\n\n\n3. ES Modules 简介3.1 基本概念ES Modules (ESM) 是 JavaScript 的官方模块标准（ECMAScript 2015 引入），用于替代传统的 CommonJS（Node.js 原生的 require 语法）。\n\n设计目标：实现静态化模块依赖，支持异步加载，适合浏览器和服务器端。\n核心优势：\n静态分析（编译时确定依赖关系，利于优化）。\n原生浏览器支持（无需打包工具即可直接使用）。\n异步加载（更适合现代应用）。\n\n\n\n3.2 基本用法使用ES 模块时，文件扩展名需要改为 .mjs；如想使用 .js 作为文件扩展名，需要在 package.json 中声明 &quot;type&quot;: &quot;module&quot;。\n模块导入\n\n导入命名导出：\nimport &#123; add, PI &#125; from &#x27;./math.js&#x27;;\n\n导入默认导出：\nimport log from &#x27;./utils.js&#x27;;\n\n混合导入：\nimport log, &#123; add &#125; from &#x27;./combined.js&#x27;;\n\n动态导入（返回 Promise）：\nconst module = await import(&#x27;./module.js&#x27;);\n\n模块导出\n\n命名导出：导出多个值。\n// math.jsexport const add = (a, b) =&gt; a + b;export const PI = 3.14;\n\n默认导出：导出一个主要值。\n\n每个文件只能有一个默认导出\n\n// utils.jsexport default function log(message) &#123;  console.log(message);&#125;\n\n3.3 注意事项(1) 文件扩展名和路径\n\n必须显式指定扩展名（如 &#39;./math.js&#39;，不能省略 .js）。\n目录索引文件需完整路径（如 &#39;./dir/index.js&#39;，不能简写为 &#39;./dir&#39;）。\n\n\n可以通过配置打包工具（如 Webpack&#x2F;Rollup&#x2F;Vite）的配置文件，配置扩展名和路径\n例如：通过配置 resolve.extensions 和 resolve.mainFiles 实现：\n// webpack.config.jsmodule.exports = &#123;  resolve: &#123;    extensions: [&#x27;.js&#x27;, &#x27;.mjs&#x27;], // 自动补全扩展名    mainFiles: [&#x27;index&#x27;],        // 自动解析目录下的 index 文件  &#125;,&#125;;\n(2) 顶层 await\n\nESM 中支持顶层 await（无需包裹在异步函数中）：\n// app.mjsconst data = await fetchData(); // 直接使用\n\n(3) 默认严格模式\n\nESM 中代码默认启用严格模式（无需 &quot;use strict&quot;）。\n\n4. CommonJS VS ES Modules在 Node.js 中，require() 和 import 是两种不同的模块系统（CommonJS 和 ES Modules），它们的加载机制有本质区别。以下是两个模块系统的比较：\n4.1 require() 是同步的，无法直接加载 ES 模块\nCommonJS 的 require()  \n\n是同步阻塞的（模块加载完成后才会执行后续代码）。\n只能加载 .js、.json、.node 等文件，默认不支持 .mjs（ES 模块）。\n如果直接 require(&#39;./es-module.mjs&#39;) 会报错：Error [ERR_REQUIRE_ESM]: Must use import to load ES Module\n\n\nES Modules 的 import  \n\n是异步的（底层使用 Promise）。\n必须用于 .mjs 文件或 package.json 中声明 &quot;type&quot;: &quot;module&quot; 的 .js 文件。\n\n\n\n4.2 在 CommonJS 中加载 ES 模块的方法由于 require() 无法直接加载 ES 模块，Node.js 提供了两种解决方案：\n方法 1：动态 import() 函数（推荐）\n\nimport() 是 ES 模块的异步加载语法，返回一个 Promise，可在 CommonJS 中使用。\n\n示例：\nES 模块（被加载方）\n// es-module.mjsexport const hello = () =&gt; &quot;Hello from ES Module&quot;;\n\nCommonJS 文件（加载方）\n// commonjs-app.js(async () =&gt; &#123;  const esModule = await import(&#x27;./es-module.mjs&#x27;);  console.log(esModule.hello()); // 输出: &quot;Hello from ES Module&quot;&#125;)();\n\n方法 2：通过 module.createRequire 创建自定义 require（复杂场景）\n\n适用于需要动态控制模块加载路径的情况：// commonjs-app.jsimport &#123; createRequire &#125; from &#x27;module&#x27;;const require = createRequire(import.meta.url);// 此时 require 仍无法加载 ES 模块，但可以加载其他 CommonJS 模块const cjsModule = require(&#x27;./commonjs-module.js&#x27;);\n\n5. Node.js核心模块5.1 global对象Node.js中的全局对象，用来存储全局变量：\n\nglobal：Node.js全局对象（类似浏览器的window）\nglobalThis：ES标准全局对象名称，Node.js中等于global\n\n与浏览器 window 对象的区别\n\n\n\n特性\nNode.js global\n浏览器 window\n\n\n\n作用域\n整个 Node.js 进程\n当前浏览器标签页\n\n\n特有 API\nprocess, Buffer, __dirname\ndocument, location, alert\n\n\n模块系统影响\n受 CommonJS&#x2F;ESM 规则约束\n直接暴露全局变量\n\n\n5.2 __dirname全局变量__dirname 是 Node.js 中的一个 全局变量，表示 当前执行脚本所在的目录的绝对路径。它是 CommonJS 模块系统的一部分，在 ES Modules（import/export）中不能直接使用。\n基本用法:\nconsole.log(__dirname);// 输出示例（Windows）: &#x27;C:\\\\Users\\\\yourname\\\\project\\\\src&#x27;// 输出示例（Linux/macOS）: &#x27;/home/yourname/project/src&#x27;\n\n始终返回 当前文件的目录路径（绝对路径）。\n不受 process.cwd()（工作目录）影响。\n\n __dirname 在 ES Modules 中的替代方案:\n在 ES Modules（import/export）中，__dirname 不可用，需要使用以下方式替代：\n替代方案 ：import.meta.url + fileURLToPath\nimport &#123; fileURLToPath &#125; from &#x27;node:url&#x27;;import &#123; dirname &#125; from &#x27;node:path&#x27;;// import.meta.url: 当前文件的 URL（ESM）const __filename = fileURLToPath(import.meta.url); // 获取当前文件的绝对路径const __dirname = dirname(__filename); // 提取目录部分console.log(__dirname); // 输出当前文件目录\n\n\n5.3 process模块process 是 Node.js 的一个核心全局对象，提供了与当前 Node.js 进程交互的多种功能和方法。它不需要通过 require() 导入即可使用。\nprocess 常用方法和属性\n\n\n\n分类\n属性&#x2F;方法\n类型\n说明\n示例\n\n\n\n进程信息\nprocess.pid\n属性\n当前进程的 PID\nconsole.log(process.pid); // 12345\n\n\n\nprocess.platform\n属性\n操作系统平台 (&#39;win32&#39;, &#39;linux&#39;, &#39;darwin&#39;)\nif (process.platform === &#39;win32&#39;) &#123; ... &#125;\n\n\n\nprocess.arch\n属性\nCPU 架构 (&#39;x64&#39;, &#39;arm&#39;)\nconsole.log(process.arch); // &#39;x64&#39;\n\n\n命令行参数\nprocess.argv\n属性（数组）\n命令行参数（[node路径, 脚本路径, ...args]）\nnode app.js arg1 → process.argv[2] === &#39;arg1&#39;\n\n\n环境变量\nprocess.env\n属性（对象）\n环境变量对象\nconsole.log(process.env.NODE_ENV); // &#39;development&#39;\n\n\n进程控制\nprocess.exit([code])\n方法\n退出进程（默认 code=0，非 0 表示失败）\nif (err) process.exit(1);\n\n\n5.4 path模块用于处理文件和目录路径的核心模块：\n常用方法：\n\npath.join([...paths])：将多个路径片段合并成一个路径\npath.resolve([...paths])：将多个路径片段解析成一个绝对路径\npath.basename(path)：返回路径的最后一部分\npath.dirname(path)：返回路径的目录部分\npath.extname(path)：返回文件的扩展名\npath.parse(path);: 解析路径\n\n示例：\n// const path = require(&#x27;path&#x27;);const path = require(&#x27;node:path&#x27;)// 合并路径const fullPath = path.join(&#x27;folder&#x27;, &#x27;subfolder&#x27;, &#x27;file.txt&#x27;);console.log(fullPath);  // folder/subfolder/file.txt// 获取绝对路径path.resolve(__dirname, &#x27;./m1.js&#x27;) // 获取文件名console.log(path.basename(&#x27;/home/user/file.txt&#x27;));  // file.txt// 获取文件扩展名console.log(path.extname(&#x27;index.html&#x27;));  // .html// 解析路径const pathObj = path.parse(&#x27;/public/images/logo.png&#x27;);console.log(pathObj);/*&#123;  root: &#x27;/&#x27;,  dir: &#x27;/public/images&#x27;,  base: &#x27;logo.png&#x27;,  ext: &#x27;.png&#x27;,  name: &#x27;logo&#x27;&#125;*/\n\n注意：\n\n工作目录(cwd)可能因执行方式不同而变化：\n\nVS Code调试执行：项目根目录\n\n命令行执行：当前脚本所在目录\n\n\n\nrequire(&#39;path&#39;) 和 require(&#39;node:path&#39;)\n\n\n\n方式\n含义\n是否强制加载核心模块\nNode.js 版本要求\n\n\n\nrequire(&#39;path&#39;)\n传统方式引入 path 模块\n可能被同名第三方模块覆盖\n所有版本\n\n\nrequire(&#39;node:path&#39;)\n显式引入 Node.js 核心 path 模块\n确保加载核心模块\nNode.js ≥ 14.18.0\n\n\n\n\n5.5 fs模块用于与文件系统交互，可以进行文件的读取、写入、删除等操作。提供同步&#x2F;异步API：\n常用方法：\n\nfs.readFile(path[, options], callback) - 读取文件\nfs.appendFile(path, data[, options], callback) - 追加内容\nfs.mkdir(path[, options], callback) - 创建目录\nfs.rm(path[, options], callback) - 删除文件&#x2F;目录\nfs.rename(oldPath, newPath, callback) - 重命名&#x2F;移动\nfs.copyFile(src, dest[, mode], callback) - 复制文件\n\n示例1：\nconst fs = require(&#x27;fs&#x27;);// 异步读取文件fs.readFile(&#x27;example.txt&#x27;, &#x27;utf8&#x27;, (err, data) =&gt; &#123;  if (err) &#123;    console.error(err);  &#125; else &#123;    console.log(data);  &#125;&#125;);// 同步读取文件const data = fs.readFileSync(&#x27;example.txt&#x27;, &#x27;utf8&#x27;);console.log(data);// 写入文件fs.writeFile(&#x27;example.txt&#x27;, &#x27;An apple a day&#x27;, err =&gt; &#123;  if (err) console.error(err);  else console.log(&#x27;成功写入文件!&#x27;);&#125;);\n\n示例2：\nconst fs = require(&#x27;fs/promises&#x27;) // Promise版本（推荐使用）// 异步读取文件（推荐）async function readFile() &#123;  try &#123;    const buffer = await fs.readFile(path.resolve(__dirname, &#x27;./readme.txt&#x27;))    console.log(buffer.toString())  &#125; catch (error) &#123;    console.error(error)  &#125;&#125;\n\n\n\n5.6 HTTP模块用于创建 HTTP 服务和客户端请求，处理 Web 服务器相关的操作。\n常用方法：\n\nhttp.createServer(callback)：创建一个 HTTP 服务器\nhttp.get(options, callback)：发起 HTTP GET 请求\nhttp.request(options, callback)：发起 HTTP 请求（支持更多方法，如 POST）\nrequest.method：获取HTTP 方法（GET, POST, PUT 等）\nrequest.url：获取请求的 URL（不包括域名）\nrequest.headers：获取请求头（对象形式）\nrequest.on(&#39;data&#39;, callback)： 接收请求体数据（POST/PUT）\nrequest.on(&#39;end&#39;, callback)：请求体接收完毕\nrequest.pipe(destination)\t：将请求数据流式传输到其他流\nresponse.setHeader(name, value)：设置单个响应头\nresponse.writeHead(statusCode, headers)：设置状态码和多个响应头\nresponse.write(data)：向客户端响应数据\nresponse.statusCode：设置状态码（默认 200）\nresponse.end()：结束响应\n\n示例1：\nconst http = require(&#x27;node:http&#x27;);// 创建一个简单的 HTTP 服务器http.createServer((req, res) =&gt; &#123;  const &#123; url, method &#125; = req;  if (url === &#x27;/&#x27; &amp;&amp; method === &#x27;GET&#x27;) &#123;    res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/plain&#x27; &#125;);    res.end(&#x27;Home Page&#x27;);  &#125; else if (url === &#x27;/api&#x27; &amp;&amp; method === &#x27;GET&#x27;) &#123;    res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;application/json&#x27; &#125;);    res.end(JSON.stringify(&#123; data: &#x27;API Response&#x27; &#125;));  &#125; else &#123;    res.writeHead(404, &#123; &#x27;Content-Type&#x27;: &#x27;text/plain&#x27; &#125;);    res.end(&#x27;Not Found&#x27;);  &#125;&#125;).listen(3000, () =&gt; &#123;  console.log(&#x27;Server running on http://localhost:3000&#x27;);&#125;);// 发起 GET 请求（客户端行为）http.get(&#x27;http://www.example.com&#x27;, (res) =&gt; &#123;  let data = &#x27;&#x27;;  res.on(&#x27;data&#x27;, chunk =&gt; data += chunk);  res.on(&#x27;end&#x27;, () =&gt; console.log(data));&#125;);\n\n示例2：\nconst http = require(&#x27;node:http&#x27;);// 配置请求const options = &#123;  hostname: &#x27;example.com&#x27;, // 目标主机  port: 80,               // 端口（HTTP默认80）  path: &#x27;/api/data&#x27;,      // 请求路径  method: &#x27;POST&#x27;,         // HTTP方法  headers: &#123;              // 请求头    &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,    &#x27;Authorization&#x27;: &#x27;Bearer token123&#x27;  &#125;&#125;;// 发起请求并处理响应const req = http.request(options, (res) =&gt; &#123;  let responseData = &#x27;&#x27;;  // 接收数据片段  res.on(&#x27;data&#x27;, (chunk) =&gt; &#123;    responseData += chunk;  &#125;);  // 响应结束  res.on(&#x27;end&#x27;, () =&gt; &#123;    console.log(&#x27;响应结果:&#x27;, responseData);  &#125;);  // 错误处理  res.on(&#x27;error&#x27;, (err) =&gt; &#123;    console.error(&#x27;响应错误:&#x27;, err);  &#125;);&#125;);// 写入请求体（如POST数据）req.write(JSON.stringify(&#123; key: &#x27;value&#x27; &#125;));// 超时控制req.setTimeout(5000, () =&gt; &#123;  req.destroy(); // 超时后终止请求  console.log(&#x27;请求超时&#x27;);&#125;);// 表示请求结束（必须调用）req.end();\n\n\n\n5.7 events 模块用于实现事件驱动的编程模型，可以创建自定义事件并监听触发。\n常用方法：\n\nEventEmitter.emit(eventName, [...args])：触发事件\nEventEmitter.on(eventName, listener)：监听事件\nEventEmitter.once(eventName, listener)：监听一次事件\n\n示例：\nconst EventEmitter = require(&#x27;events&#x27;);// 创建事件发射器class MyEmitter extends EventEmitter &#123;&#125;const myEmitter = new MyEmitter();// 监听事件myEmitter.on(&#x27;event&#x27;, () =&gt; &#123;  console.log(&#x27;Event was triggered!&#x27;);&#125;);// 触发事件myEmitter.emit(&#x27;event&#x27;);// 只监听一次myEmitter.once(&#x27;one-time&#x27;, () =&gt; &#123;    console.log(&#x27;This will only run once&#x27;);&#125;);myEmitter.emit(&#x27;one-time&#x27;);myEmitter.emit(&#x27;one-time&#x27;); // 不会触发\n\n\n\n5.8 os 模块模块提供了与操作系统相关的实用方法和属性。\n常用方法：\n\nos.platform()：返回操作系统平台\nos.cpus()：返回操作系统的 CPU 信息\nos.totalmem()：返回系统的总内存\nos.freemem()：返回系统的可用内存\n\n示例：\nconst os = require(&#x27;os&#x27;);console.log(&#x27;Platform:&#x27;, os.platform());  // linux, win32, darwin等console.log(&#x27;CPU Info:&#x27;, os.cpus());console.log(&#x27;Total Memory:&#x27;, os.totalmem());console.log(&#x27;Free Memory:&#x27;, os.freemem());\n\n\n\n5.9 url 模块用于解析和处理 URL，方便提取和操作 URL 中的各个部分。\n常用方法：\n\nurl.parse(urlString)：解析 URL 字符串，返回 URL 对象\nurl.format(urlObject)：将 URL 对象转换为字符串\nurl.resolve(from, to)：将相对路径转换为绝对路径\n\n示例：\nconst url = require(&#x27;url&#x27;);const myUrl = new URL(&#x27;https://example.com:8080/path/name?query=string#hash&#x27;);console.log(&#x27;Protocol:&#x27;, myUrl.protocol); // https:console.log(&#x27;Host:&#x27;, myUrl.host); // example.com:8080console.log(&#x27;Hostname:&#x27;, myUrl.hostname); // example.comconsole.log(&#x27;Port:&#x27;, myUrl.port); // 8080console.log(&#x27;Pathname:&#x27;, myUrl.pathname); // /path/nameconsole.log(&#x27;Search:&#x27;, myUrl.search); // ?query=stringconsole.log(&#x27;Hash:&#x27;, myUrl.hash); // #hashconsole.log(&#x27;Query:&#x27;, myUrl.searchParams.get(&#x27;query&#x27;)); // string// 解析 URL 字符串const parsedUrl = url.parse(&#x27;https://example.com/path?query=string&#x27;);console.log(parsedUrl);// 格式化 URL 对象const urlObject = &#123;    protocol: &#x27;https&#x27;,    host: &#x27;example.com&#x27;,    pathname: &#x27;/path&#x27;,    query: &#123; search: &#x27;string&#x27; &#125;&#125;;console.log(url.format(urlObject)); // https://example.com/path?search=string\n\n\n\n5.9 crypto 模块用于提供加密功能，可以进行数据加密、解密、哈希等操作。\n常用方法：\n\ncrypto.createHash(algorithm)：创建哈希实例\ncrypto.createCipheriv(algorithm, key, iv)：创建加密实例\ncrypto.createDecipheriv(algorithm, key, iv)：创建解密实例\n\n示例：\nconst crypto = require(&#x27;crypto&#x27;);// 创建哈希实例const hash = crypto.createHash(&#x27;sha256&#x27;);hash.update(&#x27;Hello World&#x27;);console.log(hash.digest(&#x27;hex&#x27;));  // 输出哈希值// 创建加密实例const key = crypto.randomBytes(32);const iv = crypto.randomBytes(16);const cipher = crypto.createCipheriv(&#x27;aes-256-cbc&#x27;, key, iv);let encrypted = cipher.update(&#x27;Hello World&#x27;, &#x27;utf8&#x27;, &#x27;hex&#x27;);encrypted += cipher.final(&#x27;hex&#x27;);console.log(encrypted);\n\n\n\n使用说明在 Node.js 中，核心模块（如 fs、path、http 等）在 CommonJS 和 ES Modules 两种模块系统中都可以直接调用，但具体使用方式略有差异。以下是详细说明：\n(1) 默认导出的差异\n\nCommonJS 中，核心模块通常导出完整的对象：\nconst fs = require(&#x27;fs&#x27;);fs.readFileSync(...);\nES Modules 中，部分核心模块可能提供命名导出（但大多数仍为默认导出）：\nimport &#123; readFileSync &#125; from &#x27;fs&#x27;; // 命名导出（部分支持）import fs from &#x27;fs&#x27;;               // 默认导出（通用）\n\n(2) 动态 require() 在 ES Modules 中不可用\n\n在 ES Modules 文件中，不能直接使用 require()（除非通过 createRequire 创建）：// ES Module 文件中（会报错）const fs = require(&#x27;fs&#x27;); // Error: require is not defined\n必须用 import：import fs from &#x27;fs&#x27;;\n\n6. 总结在 Node.js 的生态系统中，模块系统经历了从 CommonJS 到 ES Modules 的演进，每种方式都有其独特的特点和适用场景。\n\n\n\n特性\nES Modules\nCommonJS\n\n\n\n语法\nimport/export\nrequire/module.exports\n\n\n加载方式\n静态（编译时分析）\n动态（运行时加载）\n\n\n浏览器支持\n原生支持\n需打包工具（如 Webpack）\n\n\nNode.js 支持\n.mjs 或 &quot;type&quot;: &quot;module&quot;\n默认支持 .js\n\n\n顶层 await\n支持\n不支持\n\n\n适用场景\n浏览器环境和静态优化\n服务端文件系统 I&#x2F;O\n\n\n参考\nModules: CommonJS modules\nFolders as Modules\nESM 和 CommonJS 的互操作\nNode.js 官方文档\n\n","categories":["JavaScript","Node.js","模块化","JavaScript 进阶"],"tags":["模块化","CommonJS","ES Modules"]}]